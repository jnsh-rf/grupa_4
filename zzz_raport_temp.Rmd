---
title: "Analiza danych - projekt zespołowy - HR"
#subtitle: "Czyszczenie danych"
author: "Paweł Gwozdowski, Wiktoria Itrych, Wiktoria Gawryszczak"
date: Opublikowano `r format(Sys.time(), "%A %d %B %Y")`
output:
  rmdformats::robobook:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: "tango"
    number_sections: true
    fig_caption: true
    toc_depth: 3
editor_options: 
  markdown: 
    wrap: 120
fontsize: 12pt
---

```{r setup}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	include = FALSE
)
options(scipen = 999, digits=6)

# Lista bibliotek
libraries <- c(
  "rmdformats", "naniar", "visdat", "viridisLite", "ggthemes", "ggrepel",
  "deductive", "VIM", "simputation", "lumberjack", "RColorBrewer",
  "dlookr", "xts", "quantmod", "ROCR", "Information", "knitr",
  "readr", "tidyverse", "deducorrect", "rstatix", "ggcorrplot",
  "kableExtra", "DT", "mice", "finalfit", "gridExtra", "caret", "janitor"
  
  #, "tidylog"
)

packages <- c("skimr", "GGally", "plotly", "randomForest", "e1071", "rpart", "xgboost", "h2o", "rpart.plot", "corrgram", "lightgbm", "psych", "scales", "treemap", "treemapify", "repr", "cowplot", "magrittr", "ggpubr", "plotrix", "forcats", "caTools", "tree", "rattle")

# Funkcja do instalacji i wczytania bibliotek
install_and_load <- function(lib) {
  if (!require(lib, character.only = TRUE)) {
    install.packages(lib, dependencies = TRUE)
    suppressMessages(library(lib, character.only = TRUE))
  }
}

# Iteracja przez listę bibliotek
invisible(sapply(libraries, function(lib) {
  if (lib == "ggplot2") {
    options(device = "null")
    install_and_load(lib)
    options(device = "default")
  } else {
    install_and_load(lib)
  }
}))
```

```{r dane, message=FALSE, warning=FALSE, include=FALSE}
HR <- read_csv("HR.csv")
```

## Odejścia pracowników

Odejścia pracowników prowadzą do znaczących kosztów dla firmy poprzez zakłócenia w działalności, konieczność rekrutacji
i szkolenia nowych pracowników. Dlatego też, dział HR stara się zrozumieć czynniki, które wpływają na odejścia
pracowników, aby skutecznie je minimalizować. Problem odejść pracowników jest złożonym wyzwaniem, które wymaga
zaawansowanego podejścia w zarządzaniu zasobami ludzkimi. Celem projektu jest przewidywanie, którzy pracownicy mogą
zdecydować się na odejście z organizacji, aby odpowiednio wcześniej podjąć działania prewencyjne.

Analityka w tym przypadku odgrywa kluczową rolę w interpretacji danych organizacyjnych. Dzięki analizie danych można
dostrzec ukryte wzorce i trendy związane z pracownikami, umożliwiając podjęcie odpowiednich działań, które przyczynią
się do poprawy efektywności organizacji i zmniejszenia kosztów. Niniejsze badanie eksploacyjne przeprowadzono na
zestawie danych pochodzącym z działu HR.

## Struktura i opis danych

```{r dane_tabela, echo=FALSE, paged.print=TRUE}
kable(HR)
```

Zbiór danych `HR` zawiera informacje dotyczące 1,470 obecnych i byłych pracowników zebranych w 35 kolumnach, w tym
związane z ich satysfakcją z pracy, równowagą między życiem zawodowym a prywatnym, stażem pracy, doświadczeniem,
wynagrodzeniem oraz innych cech demograficznych.

## Walidacja danych

Przed przystąpieniem do dalszej analizy danych, niezwykle istotne jest upewnienie się, że dane spełniają określone
założenia w celu zapewnienia ich poprawności i spójności. Poniżej przedstawiono kluczowe założenia, które należy
zweryfikować przed rozpoczęciem właściwej analizy danych:

-   zmienne numeryczne w zestawie danych powinny przyjmować wyłącznie wartości nieujemne;
-   pracownicy spełniają wymagania związane z pełnoletnością, wiekiem emerytalnym oraz z dotychczasowym stażem pracy;
-   zmienna dotycząca odejść pracowników powinna ona przyjmować jedynie dwie kategorie: „Yes” dla osób, które opuściły
    firmę, oraz „No” dla pracowników pozostających w firmie;
-   w przypadku pracowników, dla których ta firma nie była pierwszym pracodawcą, konieczne jest odpowiednie odnotowanie
    tej informacji;
-   szkolenia pracowników odbywają się nie częściej, niż co dwa miesiące;
-   czas przeprawcowany w firmie może być krótszy niż czas od ostatniego awansu, lata pracy z tym samym menedżerem lub
    lata na obecnym stanowisku;
-   prawidłowo uzależniona wartość podwyżki od oceny pracy pracownika;
-   należycie przypisano sprawowane stanowiska do działów przedsiębiorstwa.

```{r reguly_walidacyjne, message=FALSE, warning=FALSE, include=FALSE}
walidacja_danych <- function(HR) {
  HR %>% mutate(
    AgeRule = if_else(
      Age >= 18 & Age <= 67 & Age >= (18 + TotalWorkingYears) & is.numeric(Age),
      TRUE, 
      FALSE, 
      missing = NA
    ),
    AttritionRule = if_else(
      Attrition %in% c("No", "Yes"),
      TRUE,
      FALSE,
      missing = NA
    ),
    DistanceFromHomeRule = if_else(
      DistanceFromHome >= 0 & is.numeric(DistanceFromHome), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    DailyRateRule = if_else(
      DailyRate > 0 & is.numeric(DailyRate), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    HourlyRateRule = if_else(
      is.numeric(HourlyRate) & HourlyRate > 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    MonthlyIncomeRule = if_else(
      is.numeric(MonthlyIncome) & MonthlyIncome> 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    MonthlyRateRule = if_else(
      is.numeric(MonthlyRate) & MonthlyRate > 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    NumCompaniesWorkedRule = if_else(
      is.numeric(NumCompaniesWorked) & 
      (
        NumCompaniesWorked > 0 | (NumCompaniesWorked == 0 & YearsAtCompany == TotalWorkingYears)
      ), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    TotalWorkingYearsRule = if_else(
      is.numeric(TotalWorkingYears) & TotalWorkingYears >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    TrainingTimesLastYearRule = if_else(
      is.numeric(TrainingTimesLastYear) & TrainingTimesLastYear >= 0 & TrainingTimesLastYear <= 6, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsAtCompanyRule = if_else( 
      is.numeric(YearsAtCompany) &
      YearsAtCompany >= 0 & YearsAtCompany <= 49 & (
        (YearsAtCompany >= YearsInCurrentRole) | 
        (YearsAtCompany >= YearsSinceLastPromotion) | 
        (YearsAtCompany >= YearsWithCurrManager)
      ),       TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsInCurrentRoleRule = if_else(
      is.numeric(YearsInCurrentRole) & YearsInCurrentRole >= 0 & YearsInCurrentRole < 49, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsSinceLastPromotionRule = if_else(
      is.numeric(YearsSinceLastPromotion) & YearsSinceLastPromotion >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsWithCurrManagerRule = if_else(
      is.numeric(YearsWithCurrManager) & YearsWithCurrManager >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    PercentSalaryHikeRule = if_else(
      (PerformanceRating == 1 & PercentSalaryHike == 0) |
      (PerformanceRating == 2 & PercentSalaryHike >= 1 & PercentSalaryHike <= 10) |
      (PerformanceRating == 3 & PercentSalaryHike >= 11 & PercentSalaryHike <= 19) |
      (PerformanceRating == 4 & PercentSalaryHike >= 20), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    JobRoleRule = if_else(
      (Department == "Sales" & JobRole %in% c("Sales Executive", "Sales Representative", "Manager")) |
      (Department == "Research & Development" & JobRole %in% c("Research Scientist", "Laboratory Technician", 
                                                                 "Research Director", "Manufacturing Director", 
                                                                 "Healthcare Representative", "Manager")) |
      (Department == "Human Resources" & JobRole %in% c("Human Resources", "Manager")), 
      TRUE, 
      FALSE, 
      missing = NA
    )
  )
}
```

zauważyć możemy następujące problemy : występują braki (szerzej poniżej) oraz liczba firm w której ktos pracował
wcześniej (to w dalszym kroku)

### Struktura danych

```{r str_danych, echo=TRUE}
glimpse(HR)

invisible(n_miss(HR))
invisible(prop_miss(HR))
brak_wart <- tibble(miss_var_summary(HR))
brak_wart
miss_case_table(HR)

```

Zbiór składa się z 1470 obserwacji (wierszy) oraz 35 zmiennych (kolumn). W tym zbiorze danych mamy tylko dwa typy
danych: ***numeric*** oraz ***character***.

W zbiorze danych brakuje 400 zmiennych, co stanowi 0,7774% wszystkich zmiennych. 331 rzedów cechuje się brakiem jednej
ze zmiennych, 33 rzedy dwoma brakami oraz w 1 rzędzie brakuje wartości dla 3 zmiennych.

Przewidywane odejście pracowników **Attrition** stanowić będą zmienną objaśnianą. Ze względu na fakt, iż jest to zmienna
typu ***character***, w dalszych krokach przekodowana zostanie ona na zmienną typu ***factor***.

### Statystyki opisowe - dokonczyc !!!

```{r stat_op_HR, eval=FALSE, include=FALSE}
summary(HR[, sapply(HR, is.numeric)])
stop_hr
```

## Wizualizacja braku danych

Graficzna prezentacja braku danych pozwala nam okreslić rozkład brakujących zmiennych, oraz wstępnie ocenić typ braku
danych, przydatny do podjęcia następnych kroków.

```{r viz_do_rozdzielenia, echo=TRUE}
vis_miss(HR)
vis_dat(HR)
#zgrupowane po wierszach z brakami i uporządkowanie kolumn w kolejności brakujących
vis_miss(HR, cluster = TRUE, sort_miss = TRUE)
gg_miss_fct(HR, fct = JobSatisfaction)
#wizualizacja współwystępowania braków, brakuje w 3 kolumnach, stąd nsets = 3
gg_miss_upset(HR, nsets = 3)
# pakiet finalfit
explain <- names(HR)
missplot_complete <- HR %>% missing_pattern("Age", explain)
# na tep odstawie usunieto wszystki zmienne za wyjątkiem YearsWithCurrManager, JobRole i Gender oraz zmiennych z brakami
explain_u <- c("Age", "Attrition", "MonthlyIncome", "Gender", "JobRole", "YearsWithCurrManager")
missplot_finalfit <- HR %>% missing_pattern("Age", explain_u)
```

Na podstawie graficznej przezentacji braków danych możemy zauważyć, iż braki danych w zmiennych współwystępują w:

-   Age i Attrition 12 razy;
-   Attrition i MonthlyIncome 12 razy;
-   Age i MonthlyIncome 9 razy;
-   wszystkich razem tylko 1 raz.

Zauważyć możemy również grupowanie się braków danych. Braki przyjmują wzorzec wielowymiarowy (brak w więcej niż jednej
zmiennej), niemonotonny (braki jedej zmiennej nie oznaczają braków pozostałych zmiennych) oraz połączony.

```{r kor_brak_old, eval=FALSE, warning=FALSE, include=FALSE}
ggplot(data = HR, aes(x = Age, y = MonthlyIncome)) +
  geom_point() +
  geom_miss_point() +
  scale_color_manual(values = c("darkorange", "cyan4"),
                     aesthetics = c("colour", "fill")) +
  theme_minimal()
```

```{r a_mi_scatter_braki, echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data = HR, aes(x = Age, y = MonthlyIncome)) +
  geom_point() +  # Regular points
  geom_miss_point() + # Highlight missing points
  scale_color_manual(
    name = "brakujące wartości",
    values = c("darkorange", "cyan4"),  # Colors for missing and non-missing
    labels = c("występują", "nie występują")
  ) +
  labs(
    x = "Age",
    y = "MonthlyIncome"
  ) +
  theme_minimal() +
  theme(legend.position = "right")
```

Na powyższym wykresie zobserwować możemy, iż zmienne **MonthlyIncome** oraz **Age** są ze sobą dodatnio skorelowane,
aczkolwiek istotna część obserwacji wykazuje się brakami w tychże zmiennych.

## Macierz korelacji dla zmiennych numerycznych

W tej sekcji dowiemy się, które cechy mają ze sobą dodatnią korelację. To mówi nam, czy istnieje związek między dwiema
zmiennymi. W sekcji korelacji podoba mi się to, że pozwala nam ona lepiej zrozumieć niektóre cechy, z którymi mamy do
czynienia.

### Tworzenie macierzy korelacji

```{r mx_kor_numeric, echo=TRUE, message=FALSE, warning=FALSE}
#sprawdzamy unikatowe wartości zmiennych "tekstowych" - przenieść do osobnego bloku (tymczasowo potrzebny tutaj)
all_char_values <- list(
  val_1 = table(HR$Attrition),
  val_2 = table(HR$BusinessTravel),
  val_3 = table(HR$Department),
  val_4 = table(HR$EducationField),
  val_5 = table(HR$Gender),
  val_6 = table(HR$JobRole),
  val_7 = table(HR$MaritalStatus),
  val_8 = table(HR$Over18),
  val_9 = table(HR$OverTime)
)

#uproszczenie listy all_char_values
kategorie <- lapply(all_char_values, names)

HR_factor <- HR %>%
  mutate(
    Attrition = factor(Attrition, levels = kategorie$val_1), 
    BusinessTravel = factor(BusinessTravel, levels = kategorie$val_2),
    Department = factor(Department, levels = kategorie$val_3),
    EducationField = factor(EducationField, levels = kategorie$val_4),
    Gender = factor(Gender, levels = kategorie$val_5),
    JobRole = factor(JobRole, levels = kategorie$val_6),
    MaritalStatus = factor(MaritalStatus, levels = kategorie$val_7),
    Over18 = factor(Over18, levels = kategorie$val_8),
    OverTime = factor(OverTime, levels = kategorie$val_9)
  )
## pózniej naprawić i uproscic kod

numeric_HR <- HR %>%
  mutate(Attrition = factor(Attrition, levels = kategorie$val_1)) %>%
  mutate(across(where(is.factor), as.numeric)) %>%
  select(where(is.numeric))

macierz_kor_numeric <- cor_mat(
  numeric_HR,
  method = "pearson",
  alternative = "two.sided",
  conf.level = 0.95
)

macierz_kor_numeric
```

Przy tworzeniu macierzy korelacji dla zmiennych numerycznych uwzględniono dodatkowo zmienną **Attrition**, po jej
uprzednim przekodowaniu na ***factor*** a następnie na ***numeric***, gdyż chcemy sprawdzić które zmienne są z nią
najbardziej skorelowane.

Możemy zauważyć, iż dla niektórych zmiennych niepoliczona została wartość korelacji. Wynika to z użytej metody, tj.
współczynnika korelacji Pearsona o wzorze:

$$
r = \frac{{}\sum_{i=1}^{n} (x_i - \overline{x})(y_i - \overline{y})}{\sqrt{\sum_{i=1}^{n} (x_i - \overline{x})^2  \sum_{i=1}^{n}(y_i - \overline{y})^2}}
$$

Brak wartości dla macierzy korelacji wynika z faktu, iż mianownik nie może przyjąć wartości równej 0, co może przydarzyć
się, gdy zmienna przyjmuje tylko jedną wartość. Właśnie z taką sytuacją mamy tutaj do czynienia, a tym samym zmienne te
należałoby w następnym kroku usunąć.

### Graficzna prezentacja korelacji

```{r echo=TRUE}
ggcorrplot(macierz_kor_numeric,
           insig = "blank",
           lab_size = 3, 
           method="square", 
           colors = c("#4477AA", "white", "#BB4444"), 
           ggtheme=theme_minimal(),
           legend.title = "Korelacja")
```

```{r zn_naj_skor, echo=TRUE}
mxkor_missing_var <- macierz_kor_numeric %>%
  column_to_rownames("rowname")

mxkor_age <- mxkor_missing_var %>%
  select(Age) %>%
  na.omit() %>%
  arrange(desc(abs(Age))) %>%
  filter(Age != 1)

mxkor_att <- mxkor_missing_var %>%
  select(Attrition) %>%
  na.omit() %>%
  arrange(desc(abs(Attrition))) %>%
  filter(Attrition != 1)

mxkor_moi <- mxkor_missing_var %>%
  select(MonthlyIncome) %>%
  na.omit() %>%
  arrange(desc(abs(MonthlyIncome))) %>%
  filter(MonthlyIncome != 1)

```

Na podstawie macierzy korelacji możemy stwierdzić, że zmienna **Age** skorelowana jest najsilniej z trzema zmiennymi -
**TotalWorkingYears** (0.68), **JobLevel** (0.51) oraz **MonthlyIncome** (0.49), natomiast **MonthlyIncome** ze
zmiennymi **JobLevel** (0.95), **TotalWorkingYears** (0.77), **YearsAtCompany** (0.51) oraz **Age** (0.49). Możemy je
tym samym uznać za zmienne, wykorzystane do imputacji.

Zmienna **Attrition** natomiast nie jest zbyt mocno skorelowana z żadną ze zmiennych, których to wartości absolutne
znajdują się w przedziale [0,0052 - 0,18]. Przyjmiemy tym samym do imputacji wszystkie możliwe zmienne numeryczne,
pomijając zmienne, w których występują braki.

## Imputacja danych

### Imputacja metodą drzew losowych (RPART)

```{r rpart, echo=TRUE}
im_age_rpart <- round(imputate_na(numeric_HR, Age, yvar = c("TotalWorkingYears", "JobLevel", "MonthlyIncome"), method = "rpart"), 0)

nazw_kol_hr <- colnames(numeric_HR) %>% 
  setdiff("Attrition")

#znales sposób na zagniezdzenie nazw_kol_hr w im_att_rpart
#install.packages("clipr")
#library(clipr)
writeClipboard(nazw_kol_hr)

im_att_rpart <- round(imputate_na(numeric_HR, Attrition, 
                                  yvar = c("DailyRate", "DistanceFromHome", "Education", "EmployeeCount",
                                           "EmployeeNumber", "EnvironmentSatisfaction", "HourlyRate",
                                           "JobInvolvement", "JobLevel", "JobSatisfaction", "MonthlyIncome",
                                           "NumCompaniesWorked", "PercentSalaryHike", "PerformanceRating",
                                           "RelationshipSatisfaction", "StandardHours", "StockOptionLevel",
                                           "TotalWorkingYears", "TrainingTimesLastYear","WorkLifeBalance",
                                           "YearsAtCompany", "YearsInCurrentRole", "YearsSinceLastPromotion",
                                           "YearsWithCurrManager"), 
                                  method = "rpart"), 0)

im_moi_rpart <- round(imputate_na(numeric_HR, MonthlyIncome, yvar = c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age"), method = "rpart"), 0)

plot(im_age_rpart)
plot(im_att_rpart)
plot(im_moi_rpart)
```

### Imputacja metodą Multivariate Imputation by Chained Equations (mice)

```{r mice, echo=TRUE}
im_age_mice <- round(imputate_na(numeric_HR, Age, yvar = c("TotalWorkingYears", "JobLevel", "MonthlyIncome"), method = "mice"), 0)

im_att_mice <- round(imputate_na(numeric_HR, Attrition, 
                                  yvar = c("DailyRate", "DistanceFromHome", "Education", "EmployeeCount",
                                           "EmployeeNumber", "EnvironmentSatisfaction", "HourlyRate",
                                           "JobInvolvement", "JobLevel", "JobSatisfaction", "MonthlyIncome",
                                           "NumCompaniesWorked", "PercentSalaryHike", "PerformanceRating",
                                           "RelationshipSatisfaction", "StandardHours", "StockOptionLevel",
                                           "TotalWorkingYears", "TrainingTimesLastYear","WorkLifeBalance",
                                           "YearsAtCompany", "YearsInCurrentRole", "YearsSinceLastPromotion",
                                           "YearsWithCurrManager"), 
                                  method = "mice"), 0)

im_moi_mice <- round(imputate_na(numeric_HR, MonthlyIncome, yvar = c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age"), method = "mice"), 0)

plot(im_age_mice)
plot(im_att_mice)
plot(im_moi_mice)
```

### Imputacja metoda K-najbliższych sąsiadów (KNN)

```{r kNN, echo=TRUE}
hr_knn <- VIM::kNN(numeric_HR)

im_age_knn <- hr_knn$Age
im_att_knn <- hr_knn$Attrition
im_moi_knn <- hr_knn$MonthlyIncome

ggplot() +
  geom_density(data = numeric_HR, aes(x = Age, color = "Original"), size = 1) +
  geom_density(data = hr_knn, aes(x = Age, color = "Imputed"), size = 1, linetype = "dashed") +
  labs(
    title = "Rozkład zmiennej Age",
    x = "Age",
    y = "Density",
    color = "Legend"
  ) +
  theme_minimal()

ggplot() +
  geom_density(data = numeric_HR, aes(x = Attrition, color = "Original"), size = 1) +
  geom_density(data = hr_knn, aes(x = Attrition, color = "Imputed"), size = 1, linetype = "dashed") +
  labs(
    title = "Rozkład zmiennej Attrition",
    x = "Age",
    y = "Density",
    color = "Legend"
  ) +
  theme_minimal()

ggplot() +
  geom_density(data = numeric_HR, aes(x = MonthlyIncome, color = "Original"), size = 1) +
  geom_density(data = hr_knn, aes(x = MonthlyIncome, color = "Imputed"), size = 1, linetype = "dashed") +
  labs(
    title = "Rozkład zmiennej MonthlyIncome",
    x = "Age",
    y = "Density",
    color = "Legend"
  ) +
  theme_minimal()

```

### Uzupełnianie braków danych

Na podstawie wizualnej oceny rozkładu zmiennych oryginalnych względem imputowanych przy wykorzystaniu metod RPART, MICE
oraz KNN, uznano, iż wypełnienie braków zmiennych wykonane zostanie odpowiednio:

-   Age - knn / mice
-   Att - mice i rpart (prawie identyczne), wybór mice (jako zmienna)
-   MOI - knn

**potrzebne dalsze testy sprawdzające, jak zmienne się nadają**

```{r imputacja_fin, echo=TRUE}
HR_imputowane <- HR %>%
  cbind(im_age_mice, im_att_mice, im_moi_knn) %>%
  mutate(
    Age = im_age_mice,
    Attrition = im_att_mice,
    MonthlyIncome = im_moi_knn) %>%
  select(-im_age_mice, im_att_mice, im_moi_knn) %>%
  mutate(Attrition = ifelse(Attrition == 1, "No", 
                            ifelse(Attrition == 2, "Yes", Attrition)))

view(HR_imputowane)
```

```{r janitor, echo=TRUE, message=FALSE, warning=FALSE}
# chunk do finalnej wersji tabeli, ma usuwać zbeden kolumny i naprawiać nazwy - pakietem janitor
# clean_names	Cleans names of an object (usually a data.frame).
# remove_constant	Remove constant columns from a data.frame or matrix.
# 
```
