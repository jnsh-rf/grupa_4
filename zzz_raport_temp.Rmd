---
title: "Analiza danych - projekt zespołowy - HR"
#subtitle: "Czyszczenie danych"
author: "Paweł Gwozdowski, Wiktoria Itrych, Wiktoria Gawryszczak"
date: Opublikowano `r format(Sys.time(), "%A %d %B %Y")`
output:
  rmdformats::robobook:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: "tango"
    number_sections: true
    fig_caption: true
    toc_depth: 3
editor_options: 
  markdown: 
    wrap: 80
fontsize: 12pt
---

```{r setup}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	include = FALSE
)
options(scipen = 999, digits=6)

# Lista bibliotek
libraries <- c(
  "rmdformats", "naniar", "visdat", "viridisLite", "ggthemes", "ggrepel",
  "deductive", "VIM", "simputation", "lumberjack", "RColorBrewer",
  "dlookr", "xts", "quantmod", "ROCR", "Information", "knitr",
  "readr", "tidyverse", "deducorrect", "rstatix", "ggcorrplot",
  "kableExtra", "DT", "mice", "finalfit", "gridExtra", "caret", "janitor"
  
  #, "tidylog"
)

packages <- c("skimr", "GGally", "plotly", "randomForest", "e1071", "rpart", "xgboost", "h2o", "rpart.plot", "corrgram", "lightgbm", "psych", "scales", "treemap", "treemapify", "repr", "cowplot", "magrittr", "ggpubr", "plotrix", "forcats", "caTools", "tree", "rattle")

# Funkcja do instalacji i wczytania bibliotek
install_and_load <- function(lib) {
  if (!require(lib, character.only = TRUE)) {
    install.packages(lib, dependencies = TRUE)
    suppressMessages(library(lib, character.only = TRUE))
  }
}

# Iteracja przez listę bibliotek
invisible(sapply(libraries, function(lib) {
  if (lib == "ggplot2") {
    options(device = "null")
    install_and_load(lib)
    options(device = "default")
  } else {
    install_and_load(lib)
  }
}))
```

## Opis projektu

Odejścia pracowników prowadzą do znacznych kosztów dla firmy, w tym kosztów zakłóceń w działalności, zatrudniania i szkolenia nowych pracowników. W związku z tym istnieje duże zainteresowanie HR zrozumieniem czynników wpływających na odejścia pracowników i ich minimalizacją.

Analityka pomaga nam w interpretacji danych organizacyjnych. Znajduje trendy związane z ludźmi w danych i pozwala działowi HR podjąć odpowiednie kroki, aby organizacja działała sprawnie i przynosiła zyski. Odchodzienie pracowników w korporacji jest jednym ze złożonych wyzwań, z którymi muszą sobie radzić menedżerowie i pracownicy HR. Celem projektu jest tym samym przewidywanie odejść pracowników.

## Struktura i opis danych

```{r dane, message=FALSE, warning=FALSE, include=FALSE}
HR <- read_csv("HR.csv")
```

```{r dane_tabela, echo=FALSE, paged.print=TRUE}
kable(HR)
```

Zbiór danych **HR** zawiera informacje dotyczące 1,470 obecnych i byłych pracowników, w tym związane z ich satysfakcją z pracy, równowagą między życiem zawodowym a prywatnym, stażem pracy, doświadczeniem, wynagrodzeniem i danymi demograficznymi.

### Struktura danych

```{r str_danych, echo=TRUE}
glimpse(HR)

invisible(n_miss(HR))
invisible(prop_miss(HR))
brak_wart <- tibble(miss_var_summary(HR))
brak_wart
miss_case_table(HR)

```

Zbiór składa się z 1470 obserwacji (wierszy) oraz 35 zmiennych (kolumn). W tym zbiorze danych mamy tylko dwa typy danych: ***numeric*** oraz ***character***.

W zbiorze danych brakuje 400 zmiennych, co stanowi 0,7774% wszystkich zmiennych. 331 rzedów cechuje się brakiem jednej ze zmiennych, 33 rzedy dwoma brakami oraz w 1 rzędzie brakuje wartości dla 3 zmiennych.

Przewidywane odejście pracowników **Attrition** stanowić będą zmienną objaśnianą. Ze względu na fakt, iż jest to zmienna typu ***character***, w dalszych krokach przekodowana zostanie ona na zmienną typu ***factor***.

### Statystyki opisowe - dokonczyc !!!

```{r stat_op_HR, eval=FALSE, include=FALSE}
summary(HR[, sapply(HR, is.numeric)])
stop_hr
```

## Wizualizacja braku danych

Graficzna prezentacja braku danych pozwala nam okreslić rozkład brakujących zmiennych, oraz wstępnie ocenić typ braku danych, przydatny do podjęcia następnych kroków.

```{r viz_do_rozdzielenia, echo=TRUE}
vis_miss(HR)
vis_dat(HR)
#zgrupowane po wierszach z brakami i uporządkowanie kolumn w kolejności brakujących
vis_miss(HR, cluster = TRUE, sort_miss = TRUE)
gg_miss_fct(HR, fct = JobSatisfaction)
#wizualizacja współwystępowania braków, brakuje w 3 kolumnach, stąd nsets = 3
gg_miss_upset(HR, nsets = 3)
# pakiet finalfit
explain <- names(HR)
missplot_complete <- HR %>% missing_pattern("Age", explain)
# na tep odstawie usunieto wszystki zmienne za wyjątkiem YearsWithCurrManager, JobRole i Gender oraz zmiennych z brakami
explain_u <- c("Age", "Attrition", "MonthlyIncome", "Gender", "JobRole", "YearsWithCurrManager")
missplot_finalfit <- HR %>% missing_pattern("Age", explain_u)
```

Na podstawie graficznej przezentacji braków danych możemy zauważyć, iż braki danych w zmiennych współwystępują w:

-   Age i Attrition 12 razy;
-   Attrition i MonthlyIncome 12 razy;
-   Age i MonthlyIncome 9 razy;
-   wszystkich razem tylko 1 raz.

Zauważyć możemy również grupowanie się braków danych. Braki przyjmują wzorzec wielowymiarowy (brak w więcej niż jednej zmiennej), niemonotonny (braki jedej zmiennej nie oznaczają braków pozostałych zmiennych) oraz połączony.

```{r kor_brak_old, eval=FALSE, warning=FALSE, include=FALSE}
ggplot(data = HR, aes(x = Age, y = MonthlyIncome)) +
  geom_point() +
  geom_miss_point() +
  scale_color_manual(values = c("darkorange", "cyan4"),
                     aesthetics = c("colour", "fill")) +
  theme_minimal()
```

```{r a_mi_scatter_braki, echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data = HR, aes(x = Age, y = MonthlyIncome)) +
  geom_point() +  # Regular points
  geom_miss_point() + # Highlight missing points
  scale_color_manual(
    name = "brakujące wartości",
    values = c("darkorange", "cyan4"),  # Colors for missing and non-missing
    labels = c("występują", "nie występują")
  ) +
  labs(
    x = "Age",
    y = "MonthlyIncome"
  ) +
  theme_minimal() +
  theme(legend.position = "right")
```

Na powyższym wykresie zobserwować możemy, iż zmienne **MonthlyIncome** oraz **Age** są ze sobą dodatnio skorelowane, aczkolwiek istotna część obserwacji wykazuje się brakami w tychże zmiennych.

## Macierz korelacji dla zmiennych numerycznych

W tej sekcji dowiemy się, które cechy mają ze sobą dodatnią korelację. To mówi nam, czy istnieje związek między dwiema zmiennymi. W sekcji korelacji podoba mi się to, że pozwala nam ona lepiej zrozumieć niektóre cechy, z którymi mamy do czynienia.

### Tworzenie macierzy korelacji

```{r mx_kor_numeric, echo=TRUE, message=FALSE, warning=FALSE}
#sprawdzamy unikatowe wartości zmiennych "tekstowych" - przenieść do osobnego bloku (tymczasowo potrzebny tutaj)
all_char_values <- list(
  val_1 = table(HR$Attrition),
  val_2 = table(HR$BusinessTravel),
  val_3 = table(HR$Department),
  val_4 = table(HR$EducationField),
  val_5 = table(HR$Gender),
  val_6 = table(HR$JobRole),
  val_7 = table(HR$MaritalStatus),
  val_8 = table(HR$Over18),
  val_9 = table(HR$OverTime)
)

#uproszczenie listy all_char_values
kategorie <- lapply(all_char_values, names)

HR_factor <- HR %>%
  mutate(
    Attrition = factor(Attrition, levels = kategorie$val_1), 
    BusinessTravel = factor(BusinessTravel, levels = kategorie$val_2),
    Department = factor(Department, levels = kategorie$val_3),
    EducationField = factor(EducationField, levels = kategorie$val_4),
    Gender = factor(Gender, levels = kategorie$val_5),
    JobRole = factor(JobRole, levels = kategorie$val_6),
    MaritalStatus = factor(MaritalStatus, levels = kategorie$val_7),
    Over18 = factor(Over18, levels = kategorie$val_8),
    OverTime = factor(OverTime, levels = kategorie$val_9)
  )
## pózniej naprawić i uproscic kod

numeric_HR <- HR %>%
  mutate(Attrition = factor(Attrition, levels = kategorie$val_1)) %>%
  mutate(across(where(is.factor), as.numeric)) %>%
  select(where(is.numeric))

macierz_kor_numeric <- cor_mat(
  numeric_HR,
  method = "pearson",
  alternative = "two.sided",
  conf.level = 0.95
)

macierz_kor_numeric
```

Przy tworzeniu macierzy korelacji dla zmiennych numerycznych uwzględniono dodatkowo zmienną **Attrition**, po jej uprzednim przekodowaniu na ***factor*** a następnie na ***numeric***, gdyż chcemy sprawdzić które zmienne są z nią najbardziej skorelowane.

Możemy zauważyć, iż dla niektórych zmiennych niepoliczona została wartość korelacji. Wynika to z użytej metody, tj. współczynnika korelacji Pearsona o wzorze:

$$
r = \frac{{}\sum_{i=1}^{n} (x_i - \overline{x})(y_i - \overline{y})}{\sqrt{\sum_{i=1}^{n} (x_i - \overline{x})^2  \sum_{i=1}^{n}(y_i - \overline{y})^2}}
$$

Brak wartości dla macierzy korelacji wynika z faktu, iż mianownik nie może przyjąć wartości równej 0, co może przydarzyć się, gdy zmienna przyjmuje tylko jedną wartość. Właśnie z taką sytuacją mamy tutaj do czynienia, a tym samym zmienne te należałoby w następnym kroku usunąć.

### Graficzna prezentacja korelacji

```{r echo=TRUE}
ggcorrplot(macierz_kor_numeric,
           insig = "blank",
           lab_size = 3, 
           method="square", 
           colors = c("#4477AA", "white", "#BB4444"), 
           ggtheme=theme_minimal(),
           legend.title = "Korelacja")
```

```{r zn_naj_skor, echo=TRUE}
mxkor_missing_var <- macierz_kor_numeric %>%
  column_to_rownames("rowname")

mxkor_age <- mxkor_missing_var %>%
  select(Age) %>%
  na.omit() %>%
  arrange(desc(abs(Age))) %>%
  filter(Age != 1)

mxkor_att <- mxkor_missing_var %>%
  select(Attrition) %>%
  na.omit() %>%
  arrange(desc(abs(Attrition))) %>%
  filter(Attrition != 1)

mxkor_moi <- mxkor_missing_var %>%
  select(MonthlyIncome) %>%
  na.omit() %>%
  arrange(desc(abs(MonthlyIncome))) %>%
  filter(MonthlyIncome != 1)

```

Na podstawie macierzy korelacji możemy stwierdzić, że zmienna **Age** skorelowana jest najsilniej z trzema zmiennymi - **TotalWorkingYears** (0.68), **JobLevel** (0.51) oraz **MonthlyIncome** (0.49), natomiast **MonthlyIncome** ze zmiennymi **JobLevel** (0.95), **TotalWorkingYears** (0.77), **YearsAtCompany** (0.51) oraz **Age** (0.49). Możemy je tym samym uznać za zmienne, wykorzystane do imputacji.

Zmienna **Attrition** natomiast nie jest zbyt mocno skorelowana z żadną ze zmiennych, których to wartości absolutne znajdują się w przedziale [0,0052 - 0,18]. Przyjmiemy tym samym do imputacji wszystkie możliwe zmienne numeryczne, pomijając zmienne, w których występują braki.

## Imputacja danych

### Imputacja metodą drzew losowych (RPART)

```{r rpart, echo=TRUE}
im_age_rpart <- round(imputate_na(numeric_HR, Age, yvar = c("TotalWorkingYears", "JobLevel", "MonthlyIncome"), method = "rpart"), 0)

nazw_kol_hr <- colnames(numeric_HR) %>% 
  setdiff("Attrition")

#znales sposób na zagniezdzenie nazw_kol_hr w im_att_rpart
#install.packages("clipr")
#library(clipr)
writeClipboard(nazw_kol_hr)

im_att_rpart <- round(imputate_na(numeric_HR, Attrition, 
                                  yvar = c("DailyRate", "DistanceFromHome", "Education", "EmployeeCount",
                                           "EmployeeNumber", "EnvironmentSatisfaction", "HourlyRate",
                                           "JobInvolvement", "JobLevel", "JobSatisfaction", "MonthlyIncome",
                                           "NumCompaniesWorked", "PercentSalaryHike", "PerformanceRating",
                                           "RelationshipSatisfaction", "StandardHours", "StockOptionLevel",
                                           "TotalWorkingYears", "TrainingTimesLastYear","WorkLifeBalance",
                                           "YearsAtCompany", "YearsInCurrentRole", "YearsSinceLastPromotion",
                                           "YearsWithCurrManager"), 
                                  method = "rpart"), 0)

im_moi_rpart <- round(imputate_na(numeric_HR, MonthlyIncome, yvar = c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age"), method = "rpart"), 0)

plot(im_age_rpart)
plot(im_att_rpart)
plot(im_moi_rpart)
```

### Imputacja metodą Multivariate Imputation by Chained Equations (mice)

```{r mice, echo=TRUE}
im_age_mice <- round(imputate_na(numeric_HR, Age, yvar = c("TotalWorkingYears", "JobLevel", "MonthlyIncome"), method = "mice"), 0)

im_att_mice <- round(imputate_na(numeric_HR, Attrition, 
                                  yvar = c("DailyRate", "DistanceFromHome", "Education", "EmployeeCount",
                                           "EmployeeNumber", "EnvironmentSatisfaction", "HourlyRate",
                                           "JobInvolvement", "JobLevel", "JobSatisfaction", "MonthlyIncome",
                                           "NumCompaniesWorked", "PercentSalaryHike", "PerformanceRating",
                                           "RelationshipSatisfaction", "StandardHours", "StockOptionLevel",
                                           "TotalWorkingYears", "TrainingTimesLastYear","WorkLifeBalance",
                                           "YearsAtCompany", "YearsInCurrentRole", "YearsSinceLastPromotion",
                                           "YearsWithCurrManager"), 
                                  method = "mice"), 0)

im_moi_mice <- round(imputate_na(numeric_HR, MonthlyIncome, yvar = c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age"), method = "mice"), 0)

plot(im_age_mice)
plot(im_att_mice)
plot(im_moi_mice)
```

### Imputacja metoda K-najbliższych sąsiadów (KNN)

```{r kNN, echo=TRUE}
hr_knn <- VIM::kNN(numeric_HR)

im_age_knn <- hr_knn$Age
im_att_knn <- hr_knn$Attrition
im_moi_knn <- hr_knn$MonthlyIncome

ggplot() +
  geom_density(data = numeric_HR, aes(x = Age, color = "Original"), size = 1) +
  geom_density(data = hr_knn, aes(x = Age, color = "Imputed"), size = 1, linetype = "dashed") +
  labs(
    title = "Rozkład zmiennej Age",
    x = "Age",
    y = "Density",
    color = "Legend"
  ) +
  theme_minimal()

ggplot() +
  geom_density(data = numeric_HR, aes(x = Attrition, color = "Original"), size = 1) +
  geom_density(data = hr_knn, aes(x = Attrition, color = "Imputed"), size = 1, linetype = "dashed") +
  labs(
    title = "Rozkład zmiennej Attrition",
    x = "Age",
    y = "Density",
    color = "Legend"
  ) +
  theme_minimal()

ggplot() +
  geom_density(data = numeric_HR, aes(x = MonthlyIncome, color = "Original"), size = 1) +
  geom_density(data = hr_knn, aes(x = MonthlyIncome, color = "Imputed"), size = 1, linetype = "dashed") +
  labs(
    title = "Rozkład zmiennej MonthlyIncome",
    x = "Age",
    y = "Density",
    color = "Legend"
  ) +
  theme_minimal()

```

### Uzupełnianie braków danych

Na podstawie wizualnej oceny rozkładu zmiennych oryginalnych względem imputowanych przy wykorzystaniu metod RPART, MICE oraz KNN, uznano, iż wypełnienie braków zmiennych wykonane zostanie odpowiednio:

-   Age - knn / mice
-   Att - mice i rpart (prawie identyczne), wybór mice (jako zmienna)
-   MOI - knn

**potrzebne dalsze testy sprawdzające, jak zmienne się nadają**

```{r imputacja_fin, echo=TRUE}
HR_imputowane <- HR %>%
  cbind(im_age_mice, im_att_mice, im_moi_knn) %>%
  mutate(
    Age = im_age_mice,
    Attrition = im_att_mice,
    MonthlyIncome = im_moi_knn) %>%
  select(-im_age_mice, im_att_mice, im_moi_knn) %>%
  mutate(Attrition = ifelse(Attrition == 1, "No", 
                            ifelse(Attrition == 2, "Yes", Attrition)))

view(HR_imputowane)
```

```{r janitor, echo=TRUE, message=FALSE, warning=FALSE}
# chunk do finalnej wersji tabeli, ma usuwać zbeden kolumny i naprawiać nazwy - pakietem janitor
# clean_names	Cleans names of an object (usually a data.frame).
# remove_constant	Remove constant columns from a data.frame or matrix.
# 
```
