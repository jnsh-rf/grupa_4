---
title: "Analiza danych - projekt zespołowy - HR"
#subtitle: "Czyszczenie danych"
author: "Gwozdowski, Itrych, Gawryszczak"
date: Opublikowano `r format(Sys.time(), "%A %d %B %Y")`
output:
  rmdformats::robobook:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: "tango"
    number_sections: false
    fig_caption: true
    toc_depth: 4
    code_folding: "show"
editor_options: 
  markdown: 
    wrap: 120
fontsize: 12pt
---

```{r setup, message = FALSE, warning = FALSE, include = FALSE}
options(scipen = 999, digits=6)
# mirror na Politechnice Warszawskiej
# info z tej strony https://cran.r-project.org/mirrors.html
options(repos = c(CRAN = "https://cran.mi2.ai/"))

# gwarantuje jednakowe wyniki za każdym razem
set.seed(42)

libraries <- c(
  "rmdformats", "naniar", "visdat", "viridisLite", "ggthemes", "ggrepel",
  "VIM", "RColorBrewer", "paletteer", "readr", "dlookr", "rpart",
  "Information", "knitr", "hexbin", "readr", "tidyverse", "rstatix", 
  "corrplot", "hrbrthemes", "kableExtra", "DT", "mice", "finalfit", "skimr",
  "gridExtra", "caret", "janitor", "summarytools", "ggstatsplot", "viridisLite",
  "gt", "gtsummary", "gtExtras", "patchwork", "janitor"
  #"modelsummary", "broom", "broom.mixed" # na wypadek budowy modeli
  
  #, "tidylog", # "gt", "ggforce", "gtsummary"
)

packages <- c("GGally", "plotly", "randomForest", "e1071", "rpart", "xgboost", "h2o", "rpart.plot", "corrgram", "lightgbm", "psych", "scales", "treemap", "treemapify", "repr", "cowplot", "magrittr", "ggpubr", "plotrix", "forcats", "caTools", "tree", "rattle")

# Funkcja do instalacji i wczytania bibliotek
install_and_load <- function(lib) {
  if (!require(lib, character.only = TRUE)) {
    install.packages(lib, dependencies = TRUE)
    suppressMessages(library(lib, character.only = TRUE))
  }
}

# Iteracja przez listę bibliotek
invisible(sapply(libraries, function(lib) {
  if (lib == "ggplot2") {
    options(device = "null")
    install_and_load(lib)
    options(device = "default")
  } else {
    install_and_load(lib)
  }
}))
```

```{r dane___hide, message=FALSE, warning=FALSE, include=FALSE}
HR <- read_csv("HR.csv")
```

## Odejścia pracowników

Odejścia pracowników prowadzą do znaczących kosztów dla firmy poprzez zakłócenia w działalności, konieczność rekrutacji
i szkolenia nowych pracowników. Dlatego też, dział HR stara się zrozumieć czynniki, które wpływają na odejścia
pracowników, aby skutecznie je minimalizować. Problem odejść pracowników jest złożonym wyzwaniem, które
wymagazaawansowanego podejścia w zarządzaniu zasobami ludzkimi. Celem projektu jest przewidywanie, którzy pracownicy
mogązdecydować się na odejście z organizacji, aby odpowiednio wcześniej podjąć działania prewencyjne.

Analityka w tym przypadku odgrywa kluczową rolę w interpretacji danych organizacyjnych. Dzięki analizie danych można
dostrzec ukryte wzorce i trendy związane z pracownikami, umożliwiając podjęcie odpowiednich działań, które przyczynią
się do poprawy efektywności organizacji i zmniejszenia kosztów. Niniejsze badanie eksploacyjne przeprowadzono na
zestawie danych pochodzącym z działu HR.

## 1. Opis i struktura danych

```{r dane_tabela, echo=FALSE, paged.print=TRUE}
DT::datatable(
  HR,
  options = list(
    dom = 'ltipr', 
    pageLength = 10, 
    lengthMenu = c(5, 10, 20, 50),  
    scrollX = TRUE,  
    fixedColumns = list(leftColumns = 1), 
    rownames = TRUE,  
    columnDefs = list(
      list(targets = "_all", render = JS(
        "function(data, type, row, meta) {",
        "  if (data === null || data === '') { return 'NA'; }",
        "  return data;",
        "}"))
    ) 
  ),
  rownames = TRUE  
)
```

Zbiór danych `HR` zawiera informacje dotyczące 1,470 obecnych i byłych pracowników zebranych w 35 kolumnach, w tym
związane z ich satysfakcją z pracy, równowagą między życiem zawodowym a prywatnym, stażem pracy, doświadczeniem,
wynagrodzeniem oraz innych cech demograficznych.

```{r stat_op_brudne, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}
skim(HR)
```

Analizując strukturę pliku z danymi, możemy wyciągnąć kilka istotnych wniosków dotyczących zarówno samego zbioru danych,
jak i poszczególnych zmiennych. Każdego pracownika reprezentuje zbiór 35 zmiennych, z których 26 to zmienne numeryczne,
a 9 to zmienne kategoryczne (tekstowe).

W analizowanych danych zauważamy kilka istotnych problemów, które warto uwzględnić w dalszym etapie analizy. Zauważyć
możemy występowanie braków danych trzech zmiennych tj. **Age**, **Attrition** oraz **MonthlyIncome**. Wskazuje to na
konieczność rozważenia metod uzupełniania tych braków, aby uniknąć ich wpływu na wyniki analizy.

Dodatkowo, w przypadku zmiennej **NumCompaniesWorked** wartości równe 0 mogą budzić wątpliwości, ponieważ sugerują, że
pracownik nie posiada doświadczenia zawodowego w innych przedsiębiorstwach, co, zwłaszcza w przypadku starszych
pracowników może być nietypowe. Tego rodzaju wartości należy dokładniej przeanalizować, aby zweryfikować, czy są one
wynikiem błędu w rejestracji danych, czy też stanowią rzeczywisty przypadek (np. brak wcześniejszego zatrudnienia).

## 2. Wstępna analiza danych

### 2.1. Weryfikacja poprawności danych

Przed przystąpieniem do dalszej analizy danych, niezwykle istotne jest upewnienie się, że dane spełniają określone
założenia w celu zapewnienia ich poprawności i spójności. Poniżej przedstawiono kluczowe założenia, które należy
zweryfikować przed rozpoczęciem właściwej analizy danych:

-   zmienne numeryczne w zestawie danych powinny przyjmować wyłącznie wartości nieujemne;
-   pracownicy spełniają wymagania związane z pełnoletnością, wiekiem emerytalnym oraz z dotychczasowym stażem pracy;
-   zmienna dotycząca odejść pracowników powinna ona przyjmować jedynie dwie kategorie: „Yes” dla osób, które opuściły
    firmę, oraz „No” dla pracowników pozostających w firmie;
-   w przypadku pracowników, dla których ta firma nie była pierwszym pracodawcą, konieczne jest odpowiednie odnotowanie
    tej informacji;
-   szkolenia pracowników odbywają się nie częściej, niż co dwa miesiące;
-   czas przepracowany w firmie może być krótszy niż czas od ostatniego awansu, lata pracy z tym samym menedżerem lub
    lata na obecnym stanowisku;
-   prawidłowo uzależniona wartość podwyżki od oceny pracy pracownika;
-   należycie przypisano sprawowane stanowiska do działów przedsiębiorstwa.

```{r reguly_walidacyjne, echo=TRUE, message=FALSE, warning=FALSE}
walidacja_danych <- function(HR) {
  HR %>% mutate(
    AgeRule = if_else(
      Age >= 18 & Age <= 67 & Age >= (18 + TotalWorkingYears) & is.numeric(Age),
      TRUE, 
      FALSE, 
      missing = NA
    ),
    AttritionRule = if_else(
      Attrition %in% c("Yes", "No"),
      TRUE,
      NA,
      missing = NA
    ),
    DistanceFromHomeRule = if_else(
      DistanceFromHome >= 0 & is.numeric(DistanceFromHome), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    DailyRateRule = if_else(
      DailyRate > 0 & is.numeric(DailyRate), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    HourlyRateRule = if_else(
      is.numeric(HourlyRate) & HourlyRate > 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    MonthlyIncomeRule = if_else(
      is.numeric(MonthlyIncome) & MonthlyIncome> 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    MonthlyRateRule = if_else(
      is.numeric(MonthlyRate) & MonthlyRate > 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    NumCompaniesWorkedRule = if_else(
      is.numeric(NumCompaniesWorked) & 
      (
        NumCompaniesWorked > 0 | (NumCompaniesWorked == 0 & YearsAtCompany == TotalWorkingYears)
      ), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    TotalWorkingYearsRule = if_else(
      is.numeric(TotalWorkingYears) & TotalWorkingYears >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    TrainingTimesLastYearRule = if_else(
      is.numeric(TrainingTimesLastYear) & TrainingTimesLastYear >= 0 & TrainingTimesLastYear <= 6, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsAtCompanyRule = if_else( 
      is.numeric(YearsAtCompany) &
      YearsAtCompany >= 0 & YearsAtCompany <= 49 & (
        (YearsAtCompany >= YearsInCurrentRole) | 
        (YearsAtCompany >= YearsSinceLastPromotion) | 
        (YearsAtCompany >= YearsWithCurrManager)
      ),       TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsInCurrentRoleRule = if_else(
      is.numeric(YearsInCurrentRole) & YearsInCurrentRole >= 0 & YearsInCurrentRole < 49, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsSinceLastPromotionRule = if_else(
      is.numeric(YearsSinceLastPromotion) & YearsSinceLastPromotion >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsWithCurrManagerRule = if_else(
      is.numeric(YearsWithCurrManager) & YearsWithCurrManager >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    PercentSalaryHikeRule = if_else(
      (PerformanceRating == 1 & PercentSalaryHike == 0) |
      (PerformanceRating == 2 & PercentSalaryHike >= 1 & PercentSalaryHike <= 10) |
      (PerformanceRating == 3 & PercentSalaryHike >= 11 & PercentSalaryHike <= 19) |
      (PerformanceRating == 4 & PercentSalaryHike >= 20), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    JobRoleRule = if_else(
      (Department == "Sales" & JobRole %in% c("Sales Executive", "Sales Representative", "Manager")) |
      (Department == "Research & Development" & JobRole %in% c("Research Scientist", "Laboratory Technician", 
                                                                 "Research Director", "Manufacturing Director", 
                                                                 "Healthcare Representative", "Manager")) |
      (Department == "Human Resources" & JobRole %in% c("Human Resources", "Manager")), 
      TRUE, 
      FALSE, 
      missing = NA
    )
  )
}
```

```{r wyniki_walidacji___hide, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
podsumowanie_walidacji <- walidacja_danych(HR) %>%
  select(ends_with("Rule")) %>%
  mutate(across(everything(), ~ case_when(
    is.na(.) ~ "NA",
    . == TRUE ~ "Pass",
    . == FALSE ~ "Fail"
  ), .names = "Status_{.col}")) %>%
  pivot_longer(
    cols = starts_with("Status_"),
    names_to = "Rule",
    values_to = "Status",
    names_prefix = "Status_"
  )

wykres_walidacja <- podsumowanie_walidacji %>%
  group_by(Rule, Status) %>%
  summarize(Count = n(), .groups = "drop") %>%
  mutate(Rule = gsub("Rule$", "", Rule)) %>%
  pivot_wider(names_from = Status, values_from = Count, values_fill = list(Count = 0))

wykres_walidacja_fin <- wykres_walidacja %>%
  pivot_longer(cols = -Rule, names_to = "Status", values_to = "Count")

wykres_walidacja_legenda <- wykres_walidacja_fin %>%
  mutate(total_count = sum(Count)) %>%
  group_by(Status) %>%
  mutate(Percentage = sum(Count) / total_count * 100) %>%
  summarize(Percentage = unique(Percentage)) %>%
  ungroup() %>%
  mutate(Label = paste0(Status, sprintf(" (%.1f%%)", Percentage))) %>%
  pull(Label)

# zmienić poniższe gdy dojdzie do renderu
walidacja_rezultat <- wykres_walidacja %>%
  mutate(
    Total = `Fail` + `Pass` + `NA`,
    `Fail %` = sprintf("%.1f%%", (`Fail` / Total) * 100),
    `Pass %` = sprintf("%.1f%%", (`Pass` / Total) * 100),
    `NA %` = sprintf("%.1f%%", (`NA` / Total) * 100)
  ) %>%
  select(Rule, `N Passed` = Pass, `N Failed` = Fail, `N NA` = `NA`, `Fail %`, `Pass %`, `NA %`) %>%
  kable("html", escape = FALSE, align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

kolory_walidacja <- c("Fail" = "#FB9A99", "Pass" = "#B2DF8A", "NA" = "#FDBF6F")
```

```{r wyniki_walidacja_wykres, echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
ggplot(wykres_walidacja_fin, aes(x = Rule, y = Count, fill = Status)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = kolory_walidacja, labels = wykres_walidacja_legenda) +
  theme_minimal() +
  coord_flip() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "bottom",
    legend.justification = "right",
    legend.title = element_blank(),
    plot.title = element_blank()
  )
```

```{r wyniki_walidacji_rezultat, message=FALSE, warning=FALSE, paged.print=FALSE}
walidacja_rezultat
```

Zauważono, że w przypadku zmiennej **NumCompaniesWorked** zarejestrowano 197 pracowników, których dotychczasowy staż
pracy przekraczał czas zatrudnienia w analizowanej organizacji, a jednocześnie zmienna ta przyjmowała wartośc 0 . Tego
rodzaju rozbieżność może wskazywać na błędy w rejestracji danych lub na niezgodność między doświadczeniem zawodowym a
zarejestrowaną historią zatrudnienia w firmie. Aby zapewnić poprawność dalszej analizy zależności pomiędzy odejściem
pracowników a innymi zmiennymi, w przypadku tych rozbieżności zostaną wprowadzone braki, co pozwoli uniknąć
potencjalnego zniekształcenia wyników analizy.

```{r wprowadzenie_braków, echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
HR_ncw <- walidacja_danych(HR) %>%
  mutate(NumCompaniesWorked = if_else(NumCompaniesWorkedRule == FALSE, NA, NumCompaniesWorked))

HR <- HR %>%
  mutate(NumCompaniesWorked = HR_ncw$NumCompaniesWorked)
```

### 2.2. Struktura danych po walidacji

```{r str_danych_glimpse, echo=TRUE}
glimpse(HR)
```

Graficzną prezentację danych prezentuje poniższy wykres. Zauważyć możemy, iż zmienne kategoryczne i numeryczne występują
naprzemiennie, a braki dominują w zmiennych numerycznych.

```{r}
vis_dat(HR, sort_type = FALSE)
```

```{r str_danych_mvs, echo=TRUE}
miss_var_summary(HR)
```

```{r str_danych_mcs, echo=TRUE}
miss_case_table(HR)
```

W zbiorze danych brakuje **`r n_miss(HR)`** wartości zmiennych, co stanowi **`r prop_miss(HR) * 100`%** wszystkich
wartości zmiennych. 441 rzedów cechuje się brakiem jednej ze zmiennych, 72 rzędy dwoma brakami oraz w 4 rzędach brakuje
wartości dla 3 zmiennych.

```{r wart_kategoryczne, echo=TRUE, message=FALSE, warning=FALSE}
unique_values_list <- lapply(HR[, sapply(HR, is.character)], unique)

unique_values_list_padded <- lapply(unique_values_list, function(x) {
  length(x) <- max(sapply(unique_values_list, length))
  return(x)
})

unique_values_df <- as.data.frame(unique_values_list_padded)

colnames(unique_values_df) <- names(unique_values_list)

unique_values_df
```

W powyższej ramce danych zawarto unikalne wartości dla każdej kolumny tekstowej, co pozwali na analizę możliwych
odpowiedzi w zmiennych kategorycznych. Stwierdzić należy, iż nie wykryto niekonsekwencji w danych, takich jak różne
formaty zapisu, literówki czy nieoczekiwane wartości, za wyjątkiem zmiennej **Over18**, która przyjmuje tylko jedną
wartość.

```{r wart_kategoryczne_2, echo=TRUE, message=FALSE, warning=FALSE}
limited_numeric_values <- function(df, threshold = 10) {
  numeric_cols <- names(df)[sapply(df, is.numeric) & sapply(df, function(x) n_distinct(x) < threshold)]
  
  if (length(numeric_cols) == 0) return(data.frame())
  
  unique_values_list <- lapply(df[numeric_cols], function(x) sort(unique(x)))
  
  max_length <- max(sapply(unique_values_list, length))
  unique_values_df <- as.data.frame(lapply(unique_values_list, `length<-`, max_length))
  unique_values_df <- unique_values_df[rowSums(!is.na(unique_values_df)) > 0, ]
  
  return(unique_values_df)
}

limited_numeric_values(HR)
```

Powyższa ramka prezentuje wartości zmiennych numerycznych posiadających mniej niż 10 unikatowych wartości. Zmienne te
można uznać za zmienne kategoryczne, za wyjątkiem zmiennych **EmployeeCount** oraz **StandardHours** przyjmujących tylko
jedną wartość, oraz **TrainingTimesLastYear**, reprezentującej liczbę odbytych przez pracownika szkoleń w roku
poprzednim, która powinna być traktowana jako zmienna numeryczna.

```{r wart_unikatowe__hide, echo=TRUE, message=FALSE, warning=FALSE}
unique_columns <- function(df) {
  col_names <- names(df)
  unique_cols <- col_names[sapply(df, function(x) {
    is.vector(x) && !any(duplicated(x)) && (!is.numeric(x) || all(x == round(x)))
  })]
  return(unique_cols)
}
```

Zbiór danych zawiera ponadto jedną zmienną **`r paste(unique_columns(HR))`**, która to posiada wyłącznie unikatowe
wartości. Stanowią one unikalne identyfikatory pracownika, które nie wnoszą istotnych informacji dla analizy.

-   Przewindefineddywane odejście pracowników **Attrition** stanowić będą zmienną objaśnianą. Ze względu na fakt, iż
    jest to zmienna typu ***character***, w dalszych krokach przekodowana zostanie ona na zmienną typu ***factor***.

### 2.3. Wizualna identyfikacja braków danych

Analiza graficzna braków danych pozwala na szybkie zidentyfikowanie obszarów, w których występują niekompletne
informacje. Dzięki wizualizacji możliwe jest określenie rozkładu brakujących wartości w poszczególnych zmiennych oraz
dostrzeżenie potencjalnych zależności między nimi. Pozwala to lepiej zrozumieć strukturę danych i ocenić charakter
braków, co warunkować będzie wybór odpowiednich metod imputacji.

#### 2.3.1 Analiza grupowań braków danych

```{r brak_viz_grupa, echo=TRUE, message=FALSE, warning=FALSE}
vis_miss(HR, cluster = TRUE, sort_miss = TRUE)
```

Powyższy wykres przedstawia uporządkowaną strukturę, w której obserwacje o podobnych wzorcach braków są ze sobą
grupowane, co umożliwia lepszą identyfikację występujących zależności, a uporządkowanie kolumn według częstości braków
pozwala na łatwiejsze zlokalizowanie zmiennych z najwyższym odsetkiem brakujących wartości. Na jego podstawie zauważyć
można, że większość braków zmiennych jest niezależna od braków innych zmiennych, tylko nieznaczna część braków
współwystępuje z brakami innych zmiennych.

```{r brak_viz_upset, echo=TRUE, message=FALSE, warning=FALSE}
gg_miss_upset(HR, nsets = 4)
```

Powyższe obserwacje potwierdza wykres typu UpSet, na podstawie którego możemy zauważyć interesujące zależności między
zmiennymi. Wszczególności braki danych w różnych zmiennych występują w następujących kombinacjach:

-   Age i Attrition – 12 przypadków,
-   Age i NumCompaniesWorked - 11 przypadków,
-   Age i MonthlyIncome – 7 przypadków,
-   Age, MonthlyIncome i NumCompaniesWorked – 2 przypadki,
-   Age, Attrition i MonthlyIncome – 2 przypadki,
-   Attrition i NumCompaniesWorked – 16 przypadków,
-   Attrition i MonthlyIncome – 11 przypadków,
-   Attrition, MonthlyIncome i NumCompaniesWorked – 2 przypadki,
-   MothlyIncome i NumCompaniesWorked - 15 przypadków.

```{r brak_viz_pattern}
explain <- names(HR)
missplot_complete <- HR %>% missing_pattern("Age", explain)
```

```{r brak_viz_pattern2}
VIM::aggr(HR, combined = TRUE, sortCombs = FALSE)
```

Zauważyć można, iż powyższe wykresy potwierdzają grupowanie się braków danych. Stwierdzić można, iż braki przyjmują
wzorzec wielowymiarowy (braki w więcej niż jednej zmiennej), niemonotonny (braki jedej zmiennej nie oznaczają braków
pozostałych zmiennych) oraz połączony, gdyż braki nie obejmują całej zmiennej, a tym samym pozwalają na określenie
zależności pomiędzy zmiennymi, w tym korelacji.

Kombinacje braków wartości zmiennych, sugerują iż mogą być one całkowicie losowe (Missing Completely At Random) lub są
zależne od innych zmiennych w zbiorze (Missing At Random), co wskazuje na konieczność zastosowania bardziej
zaawansowanych metod imputacji.

#### 2.3.2. Analiza współwystepowania braków

Wykres rozrzutu zmiennych ciągłych, takich jak **Age** i **MonthlyIncome**, dobrze obrazuje zależności między
obserwacjami, gdyż każda wartość jest unikalnie rozmieszczona na osi, co umożliwia łatwe wykrycie zależności zarówno
pomiędzy brakami danych, jak i samymi danymi.

Natomiast w przypadku zmiennych dyskretnych, takich jak **Attrition** (zmienna binarna) i **NumCompaniesWorked**
(przyjmująca ograniczoną liczbę wartości), wykres rozrzutu charakteryzuje się nakładania się punktów, natomiast inne
typy wykresów nie radzą sobie z prezentacją zależności pomiędzy brakami w wartościach poszczególnych zmiennych.
Zastosowanie wykresów dla tychże zmiennych nie przyniesie tym samym dodatkowych informacji, można jednakże zastosować
**Attrition** do grupowania zmiennych ciągłych, przy czym zmienna **NumCompaniesWorked** posiada zbyt wiele wartości, co
uniemożliwia jej efektywne zastosowanie w tym celu.

```{r brak_viz_a_mi_scatter, echo=TRUE, message=FALSE, warning=FALSE}
ami_sc_viz1 <- ggplot(data = HR, aes(x = Age, y = MonthlyIncome)) +
  geom_point() +
  geom_miss_point() +
  geom_smooth(method = "lm", se = FALSE, na.rm = TRUE, color = "black") +
  scale_color_manual(
    name = "Brakujące wartości",
    values = c("darkorange", "cyan4"),
    labels = c("występują", "nie występują")
  ) +
  labs(
    x = "Age",
    y = "MonthlyIncome"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

ami_sc_viz2 <- ggplot(data = HR, aes(x = Age, y = MonthlyIncome, color = Attrition, group = Attrition)) +     
  geom_point() +     
  geom_miss_point() +     
  geom_smooth(method = "lm", se = FALSE, na.rm = TRUE) +     
  scale_color_paletteer_d("khroma::bright", name = "Attrition", direction = 1, na.value = "black") +  
  labs(x = "Age", y = "MonthlyIncome") +     
  theme_minimal() +     
  theme(legend.position = "bottom")

ami_sc_vizcomb <- wrap_plots(ami_sc_viz1, ami_sc_viz2, nrow = 1)
ami_sc_vizcomb
```

Możemy zauważyć, że zmienne **MonthlyIncome** oraz **Age** wykazują dodatnią korelację – wraz ze wzrostem wieku
miesięczney dochód rośnie. Linia trendu potwierdza tę zależność, sugerując, że starsi pracownicy generalnie osiągają
wyższe dochody. Braki danych co do wieku pracownika (oznaczone na osi pionowej) dotyczą głównie pracowników o niższym i
średnim dochodzie, natomiast braki danych, co do miesięcznego dochodu (oznaczone na osi poziomej) cechują się mniej
więcej równym rozkładem.

Dodatkowo zauważyć należy, iż braki w zmiennych **Age** i **MonthlyIncome** nie wykazują szczególnie wyraźnego
uzależnienia od tego, czy pracownik odszedł z przedsiębiorstwa, natomiast brak danych dotyczących odejść dotyczy głównie
pracowników relatywnie młodszych i o niższym miesięcznym dochodzie.

Warto przy tym zaznaczyć, że metodę regresji liniowej, zastosowano wyłącznie do kompletnych przypadków, co minimalizuje
potencjalne zniekształcenia, jakie mogłyby wyniknąć z uśredniania wartości przy obecności braków.

### 2.4. Test Little'a MCAR (Missing Completely at Random)

W celu sprawdzenia, czy brakujące dane są brakujące całkowicie losowo (MCAR), przeprowadzono test statystyczny, który
ocenia tę hipotezę. Jest to istotne, ponieważ jeśli dane są MCAR, możemy uznać, że brakujące wartości nie wprowadzają
uprzedzeń do analiz i bezpiecznie zastosować metody imputacji braków.

W kontekście wcześniejszych obserwacji wykresów, gdzie mogły pojawić się pewne wstępne sygnały co do charakteru braków
danych, przeprowadzenie testu Little’a MCAR umożliwia statystyczną weryfikację tych obserwacji. Test ten, zaproponowany
przez R. Little’a (1988), służy do sprawdzenia, czy brakujące dane w zbiorze są całkowicie losowe. W praktyce test ten
ocenia, czy wzorce braków danych nie wykazują żadnej systematycznej zależności od wartości obserwowanych (ani
nieobserwowanych) zmiennych.

**Hipoteza testu:**

-   **Hipoteza zerowa (H₀)**: Dane są brakujące całkowicie losowo (MCAR). Oznacza to, że brakujące wartości nie mają
    żadnej zależności ani z obserwowanymi, ani z nieobserwowanymi zmiennymi.
-   **Hipoteza alternatywna (H₁)**: Dane nie są brakujące całkowicie losowo, czyli brakujące wartości są powiązane z
    obserwowanymi lub nieobserwowanymi zmiennymi w zbiorze danych.

```{r MCAR_test, echo=TRUE, message=FALSE, warning=FALSE}
HR_mcar_test <- HR %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(across(where(is.factor), ~ as.numeric(.))) %>%
  remove_constant()
mcar_test(HR_mcar_test)
```

**Interpretacja:**

-   **Wartość p = 0,109** (większa od typowego poziomu istotności 0,05) wskazuje, że nie ma wystarczających dowodów, aby
    odrzucić hipotezę zerową (H₀). Oznacza to, że brakujące dane można uznać za **brakujące całkowicie losowo (MCAR)**.
-   **Liczba wzorców brakujących danych** wynosząca 14 wskazuje, że w zbiorze występuje 14 różnych kombinacji zmiennych
    z brakującymi wartościami, co potwierdza wcześniejsze obserwacje.

Wykorzystana metoda w pakiecie `naniar` stanowi implementację testu Little’a MCAR, o której więcej można przeczytać w
oryginalnym artykule:

> Little, R. J. A. (1988). "A Test of Missing Completely at Random for Multivariate Data with Missing Values." *Journal
> of the American Statistical Association*, 83(404), 1198–1202.

### 2.5. Zidentyfikowane problemy w bazie danych

-   Łączna liczba brakujących danych w zbiorze wynosi **r n_miss(HR)**. Konieczne jest tym samym zastosowanie metod
    uzupełnienia braków danych uwzględniających złożony charakter braków danych.
-   Zmienne tekstowe **Department**, **EducationField**, **Gender**, **JobRole** oraz **MaritalStatus** powinny być
    zakodowane jako zmienne kategorialne (***factor***), podczas gdy zmienne tekstowe **Attrition**, **BusinessTravel**,
    **OverTime** oraz numeryczne **Education**, **EnvironmentSatisfaction**, **JobInvolvement**, **JobLevel**,
    **JobSatisfaction**, **PerformanceRating**, **RelationshipSatisfaction**, **StockOptionLevel** oraz
    **WorkLifeBalance**, powinny być uporządkowanymi zmiennymi kategorialnymi (***ordered factor***).
-   Zmienne **EmployeeCount**, **EmployeeNumber**, **StandardHours** oraz **Over18** nie dostarczają nowych informacji
    analitycznych i zostaną usunięte ze zbioru danych.

## 3. Czyszczenie danych

### 3.1. Usuwanie zbędnych kolumn

```{r usuwanie_zb_kol, echo=TRUE, message=FALSE, warning=FALSE}
HR_czyste <- HR %>%
  select(- EmployeeCount, - EmployeeNumber, - StandardHours, - Over18)
```

### 3.2. Przekodowanie zmiennych

Poniższy kod przekształca wskazane w rozdziale 2.5. zmienne na zmienne kategorialne (***factor***) oraz uporządkowene
kategorialne (***ordered factor***) z nadaniem odpowiednich etykiet (***labels***). Jest to standardowa praktyka w w
przygotowaniu danych do analizy statystycznej. Umożliwia to stosowanie różnych metod statystycznych i modeli, oraz
pozwala na łatwą konwersję na zmienne numeryczne, jeżeli jest to wymagane.

```{r przekodowanie_zmiennych, echo=TRUE, message=FALSE, warning=FALSE}
HR_czyste <- HR_czyste %>%
  mutate(
    # Zmienne kategorialne nieuporządkowane (bazowe tekstowe)
    Department = factor(case_when(
      Department == "Human Resources" ~ 1,
      Department == "Research & Development" ~ 2,
      Department == "Sales" ~ 3
    ), levels = 1:3, labels = c("Kadry", "Badania i Rozwój", "Sprzedaż"), ordered = FALSE),

    EducationField = factor(case_when(
      EducationField == "Human Resources" ~ 1,
      EducationField == "Life Sciences" ~ 2,
      EducationField == "Marketing" ~ 3,
      EducationField == "Medical" ~ 4,
      EducationField == "Technical Degree" ~ 5,
      EducationField == "Other" ~ 6
    ), levels = 1:6, labels = c("Zarządzanie Zasobami Ludzkimi", "Nauki Przyrodnicze", "Marketing", "Medyczne", "Techniczne", "Inne"), ordered = FALSE),

    Gender = factor(case_when(
      Gender == "Female" ~ 0,
      Gender == "Male" ~ 1
    ), levels = 0:1, labels = c("Kobieta", "Mężczyzna"), ordered = FALSE),

    JobRole = factor(case_when(
      JobRole == "Healthcare Representative" ~ 1,
      JobRole == "Human Resources" ~ 2,
      JobRole == "Laboratory Technician" ~ 3,
      JobRole == "Manager" ~ 4,
      JobRole == "Manufacturing Director" ~ 5,
      JobRole == "Research Director" ~ 6,
      JobRole == "Research Scientist" ~ 7,
      JobRole == "Sales Executive" ~ 8,
      JobRole == "Sales Representative" ~ 9
    ), levels = 1:9, labels = c("Przedstawiciel Medyczny", "Pracownik Działu Kadr", "Technik Laboratoryjny", "Menedżer", "Dyrektor Produkcji", "Dyrektor Badań", "Pracownik Działu Badań", "Dyrektor Sprzedaży", "Przedstawiciel Handlowy"), ordered = FALSE),

    MaritalStatus = factor(case_when(
      MaritalStatus == "Single" ~ 1,
      MaritalStatus == "Married" ~ 2,
      MaritalStatus == "Divorced" ~ 3
    ), levels = 1:3, labels = c("Panna/Kawaler", "Żonata/y", "Rozwiedziona/y"), ordered = FALSE),

    # Zmienne kategorialne uporządkowane (bazowe tekstowe)
    Attrition = factor(case_when(
      Attrition == "No" ~ 0,
      Attrition == "Yes" ~ 1
    ), levels = 0:1, labels = c("Nie", "Tak"), ordered = TRUE),

    BusinessTravel = factor(case_when(
      BusinessTravel == "Non-Travel" ~ 0,
      BusinessTravel == "Travel_Rarely" ~ 1,
      BusinessTravel == "Travel_Frequently" ~ 2
    ), levels = 0:2, labels = c("Brak", "Rzadko", "Często"), ordered = TRUE),

    OverTime = factor(case_when(
      OverTime == "No" ~ 0,
      OverTime == "Yes" ~ 1
    ), levels = 0:1, labels = c("Nie", "Tak"), ordered = TRUE),

    # Zmienne kategorialne uporządkowane (bazowe numeryczne)
    Education = factor(Education, levels = 1:5, labels = c("Średnie i niższe", "Policealne (techniczne)", "Licencjat", "Magister", "Doktor"), ordered = TRUE),
    EnvironmentSatisfaction = factor(EnvironmentSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    JobInvolvement = factor(JobInvolvement, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    JobLevel = factor(JobLevel, levels = 1:5, labels = c("Najniższy", "Niski", "Średni", "Wysoki", "Najwyższy"), ordered = TRUE),
    JobSatisfaction = factor(JobSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    PerformanceRating = factor(PerformanceRating, levels = 1:4, labels = c("Niska", "Dobra", "Znakomita", "Wybitna"), ordered = TRUE),
    RelationshipSatisfaction = factor(RelationshipSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    WorkLifeBalance = factor(WorkLifeBalance, levels = 1:4, labels = c("Zła", "Przeciętna", "Dobra", "Świetna"), ordered = TRUE),
    StockOptionLevel = factor(StockOptionLevel, levels = 0:3, labels = c("Brak", "Niski", "Średni", "Wysoki"), ordered = TRUE)
  )
```

Graficzną prezentację przekodowanych danych prezentuje poniższy wykres, w celu zwięskzenia czytelności zmienne zostały
pogrupowane po typie zmiennej.

```{r viz_group, echo=TRUE, message=FALSE, warning=FALSE}
visdat::vis_dat(HR_czyste, sort_type = TRUE)
```

### 3.3. Imputacja danych

W analizie danych zbioru HR istotnym etapem przygotowania danych jest uzupełnienie brakujących wartości. Braki danych (w
naszym przypadku `r n_miss(HR_czyste)` wartości) mogą znacząco wpłynąć na wyniki analiz statystycznych i modele
predykcyjne, prowadząc do błędnych wniosków. W związku z tym konieczne jest wdrożenie odpowiednich metod imputacji,
które pozwolą na kompleksowe uzupełnienie braków, a tym samym na zwiększenie wiarygodności dalszych analiz.

Mechanizm braków w naszym zbiorze danych został określony jako MCAR (Missing Completely at Random), co oznacza, że
brakujące dane występują losowo i nie są powiązane z innymi obserwowanymi ani nieobserwowanymi zmiennymi. W celu
uwzględnienia charakteru braku danych oraz typu danych w niniejszym rozdziale zaprezentowane zostaną trzy różne
podejścia do imputacji:

1.  **Metoda k-Najbliższych Sąsiadów** (kNN)**\
    **Metoda kNN (k-Nearest Neighbours) uzupełnia brakujące dane na podstawie podobieństwa obserwacji. Dla każdej
    obserwacji z brakującą wartością wyszukiwani są najbliżsi sąsiedzi (na podstawie innych zmiennych) i wartość
    imputowana jest na podstawie ich danych. Metoda ta jest intuicyjna i dobrze sprawdza się, gdy założymy, że podobne
    obserwacje mają podobne wartości zmiennych.

2.  **Metoda** **Multivariate Imputation by Chained Equations** (mice)**\
    **mice to zaawansowana technika wielokrotnej imputacji, która pozwala na stworzenie kilku kompletnych zbiorów
    danych. Metoda ta polega na iteracyjnym uzupełnianiu brakujących wartości przy użyciu modeli statystycznych, takich
    jak regresja logistyczna dla zmiennych *binarnych* (**Attrition**) oraz *predictive mean matching* (pmm) dla
    zmiennych *ciągłych* (**MonthlyIncome** i **Age**) lub *dyskretnych* (**NumCompaniesWorked**). Dzięki podejściu
    wielokrotnemu jesteśmy w stanie uwzględnić niepewność imputacji, co przekłada się na bardziej wiarygodne oszacowanie
    brakujących danych.

3.  **Metoda drzew decyzyjnych** (rpart) **\
    **Imputacja przy użyciu drzew decyzyjnych (Recursive Partitioning and Regression Trees) polega na budowie modelu
    predykcyjnego dla każdej zmiennej z brakami. Dla zmiennych ciągłych stosowana jest regresja drzew decyzyjnych,
    natomiast dla zmiennych kategorycznych – klasyfikacyjnych. Metoda ta jest szczególnie przydatna, gdy zależności
    między zmiennymi są nieliniowe lub bardziej złożone. Drzewa decyzyjne potrafią wychwycić te zależności, co pozwala
    na precyzyjne uzupełnienie brakujących wartości, nawet gdy dane są kompletne zgodnie z założeniem MCAR.

Kryterium decyzyjnym do wyboru zmiennych, na podstawie których imputowane będą wartości metodami **mice** i **rpart**,
będzie wartość współczynnika korelacji liniowej Pearsona, którego wzór jest następujący:

$$
r_{xy} = \frac{{}\sum_{i=1}^{n} (x_i - \overline{x})(y_i - \overline{y})}{\sqrt{\sum_{i=1}^{n} (x_i - \overline{x})^2  \sum_{i=1}^{n}(y_i - \overline{y})^2}}
$$

Wartość współczynnika korelacji mieści się w przedziale domkniętym [−1, 1]. Im większa jego wartość bezwzględna, tym
silniejsza jest zależność liniowa między zmiennymi. r~xy~ = 0 oznacza brak liniowej zależności między cechami. r~xy~ = 1
oznacza dokładną dodatnią liniową zależność między cechami, natomiast r~xy~ = -1 oznacza dokładną ujemną liniową
zależność między cechami. W celu utworzenia macierzy korelacji zmienne kategorialne przekształcone zostaną na zmienne
numeryczne.

#### 3.3.1. Tworzenie macierzy korelacji

```{r mx_kor_numeric, echo=TRUE, message=FALSE, warning=FALSE, paged.print=TRUE}
numeric_HR <- HR_czyste %>%
  mutate(across(where(is.factor), as.numeric)) %>%  
  select(where(is.numeric))

macierz_kor_numeric <- cor_mat(
  numeric_HR,
  method = "pearson",
  alternative = "two.sided",
  conf.level = 0.95) 

macierz_kor_numeric_mx <- macierz_kor_numeric %>%
  column_to_rownames(var = "rowname") %>%
  as.matrix()


#DT::datatable(macierz_kor_numeric, 
#              options = list(
#                dom = 'ltipr',  # Hide search bar, keep length menu & pagination
#                pageLength = 10, # Default rows displayed
#                lengthMenu = c(5, 10, 20, 50), # Dropdown for number of rows
#                scrollX = TRUE   # Enable horizontal scrolling
#              ),
#              rownames = TRUE)  # Hide row numbers
```

#### 3.3.2. Macierz korelacji zmiennych przed imputacją

```{r kor_viz_preimp, echo=TRUE, message=FALSE, warning=FALSE}
corrplot(
  macierz_kor_numeric_mx,
  method = "color",
  type = "upper",
  col = colorRampPalette(c("#4477AA", "white", "#BB4444"))(200),
  insig = "blank",
  tl.cex  = 0.9
)
```

```{r zn_naj_skor, message=FALSE, warning=FALSE, include=FALSE}
mxkor_missing_var <- macierz_kor_numeric %>%
  column_to_rownames("rowname")

mxkor_age <- mxkor_missing_var %>%
  select(Age) %>%
  na.omit() %>%
  arrange(desc(abs(Age))) %>%
  filter(Age != 1)

mxkor_att <- mxkor_missing_var %>%
  select(Attrition) %>%
  na.omit() %>%
  arrange(desc(abs(Attrition))) %>%
  filter(Attrition != 1)

mxkor_moi <- mxkor_missing_var %>%
  select(MonthlyIncome) %>%
  na.omit() %>%
  arrange(desc(abs(MonthlyIncome))) %>%
  filter(MonthlyIncome != 1)

mxkor_ncw <- mxkor_missing_var %>%
  select(NumCompaniesWorked) %>%
  na.omit() %>%
  arrange(desc(abs(NumCompaniesWorked))) %>%
  filter(NumCompaniesWorked != 1)
```

```{r mxkor_tab, echo=TRUE, message=FALSE, warning=FALSE}
mxkor_age
mxkor_att
mxkor_moi
mxkor_ncw
```

Na podstawie macierzy korelacji zauważamy:

- zmienna **Age** skorelowana jest najsilniej z trzema zmiennymi - **TotalWorkingYears** (0.68), **JobLevel** (0.51) oraz **MonthlyIncome** (0.49);
- **MonthlyIncome** ze zmiennymi **JobLevel** (0.95), **TotalWorkingYears** (0.77), **YearsAtCompany** (0.51) oraz **Age** (0.49);
- zmienne **Attrition** oraz **NumCompaniesWorked** natomiast nie sa zbyt mocno skorelowana z żadną ze zmiennych, których to wartości absolutne znajdują się w przedziale kolejno [0,0052 - 0,24] oraz [0.0067 - 0,30]. Przyjmiemy tym samym do imputacji wszystkie możliwe zmienne numeryczne, pomijając zmienne, w których występują braki.

Wybór zmiennych do imputacji prezentuje poniższy kod.

```{r predictors, echo=TRUE, message=FALSE, warning=FALSE}
napdst_Age <- c("TotalWorkingYears", "JobLevel", "MonthlyIncome")
napdst_Attrition <- c("DailyRate", "DistanceFromHome", "Education", "EnvironmentSatisfaction", 
                      "HourlyRate", "JobInvolvement", "JobLevel", "JobSatisfaction", 
                      "PercentSalaryHike", "PerformanceRating", 
                      "RelationshipSatisfaction", "StockOptionLevel", "TotalWorkingYears", 
                      "TrainingTimesLastYear", "WorkLifeBalance", "YearsAtCompany", 
                      "YearsInCurrentRole", "YearsSinceLastPromotion", "YearsWithCurrManager")
napdst_MonthlyIncome <- c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age")
napdst_NumCompaniesWorked <- c("DailyRate", "DistanceFromHome", "Education", "EnvironmentSatisfaction", 
                               "HourlyRate", "JobInvolvement", "JobLevel", "JobSatisfaction", 
                               "PercentSalaryHike", "PerformanceRating", 
                               "RelationshipSatisfaction", "StockOptionLevel", "TotalWorkingYears", 
                               "TrainingTimesLastYear", "WorkLifeBalance", "YearsAtCompany", 
                               "YearsInCurrentRole", "YearsSinceLastPromotion", "YearsWithCurrManager")
```

```{r fix_dla_imp__hide, echo=TRUE, message=FALSE, warning=FALSE}
imputed_data <- HR_czyste %>%
  mutate(
    Department = as.numeric(Department),
    EducationField = as.numeric(EducationField),
    Gender = as.numeric(Gender),
    JobRole = as.numeric(JobRole),
    MaritalStatus = as.numeric(MaritalStatus),
    Attrition = as.numeric(Attrition),
    BusinessTravel = as.numeric(BusinessTravel),
    OverTime = as.numeric(OverTime),
    Education = as.numeric(Education),
    EnvironmentSatisfaction = as.numeric(EnvironmentSatisfaction),
    JobInvolvement = as.numeric(JobInvolvement),
    JobLevel = as.numeric(JobLevel),
    JobSatisfaction = as.numeric(JobSatisfaction),
    PerformanceRating = as.numeric(PerformanceRating),
    RelationshipSatisfaction = as.numeric(RelationshipSatisfaction),
    WorkLifeBalance = as.numeric(WorkLifeBalance),
    StockOptionLevel = as.numeric(StockOptionLevel)
  )
imputed_data_c <- imputed_data
```

```{r imputed_data, echo=TRUE, message=FALSE, warning=FALSE}
imputed_data <- imputed_data %>%  
  mutate(
    Age_knn = round_half_up(kNN(imputed_data_c, variable = "Age")$Age),    
    Age_mice = round_half_up(imputate_na(imputed_data_c, xvar = "Age", yvar = napdst_Age, method = "mice", print_flag = FALSE)),    
    Age_rpart = round_half_up(imputate_na(imputed_data_c, xvar = "Age", yvar = napdst_Age, method = "rpart")),
      
    Attrition_knn = round_half_up(kNN(imputed_data_c, variable = "Attrition")$Attrition),    
    Attrition_mice = round_half_up(imputate_na(imputed_data_c, xvar = "Attrition", yvar = napdst_Attrition, method = "mice", print_flag = FALSE)),    
    Attrition_rpart = round_half_up(imputate_na(imputed_data_c, xvar = "Attrition", yvar = napdst_Attrition, method = "rpart")),
    
    MonthlyIncome_knn = round_half_up(kNN(imputed_data_c, variable = "MonthlyIncome")$MonthlyIncome),    
    MonthlyIncome_mice = round_half_up(imputate_na(imputed_data_c, xvar = "MonthlyIncome", yvar = napdst_MonthlyIncome, method = "mice", print_flag = FALSE)),    
    MonthlyIncome_rpart = round_half_up(imputate_na(imputed_data_c, xvar = "MonthlyIncome", yvar = napdst_MonthlyIncome, method = "rpart")),
      
    NumCompaniesWorked_knn = round_half_up(kNN(imputed_data_c, variable = "NumCompaniesWorked")$NumCompaniesWorked),    
    NumCompaniesWorked_mice = round_half_up(imputate_na(imputed_data_c, xvar = "NumCompaniesWorked", yvar = napdst_NumCompaniesWorked, method = "mice", print_flag = FALSE)),    
    NumCompaniesWorked_rpart = round_half_up(imputate_na(imputed_data_c, xvar = "NumCompaniesWorked", yvar = napdst_NumCompaniesWorked, method = "rpart"))
  )
```

```{r imputed_data_viz}
create_plot <- function(data, original, imputed, title) {
  ggplot2::ggplot(data) +
    ggplot2::geom_density(ggplot2::aes(x = {{ original }}), color = "#96d170", alpha = 0.4) + 
    ggplot2::geom_density(ggplot2::aes(x = {{ imputed }}), color = "#cb8873", alpha = 0.4) + 
    ggplot2::labs(title = title, x = "Wartość", y = "Gęstość rozkładu") +
    ggplot2::theme_minimal()
}

plot_age_knn <- create_plot(imputed_data, Age, Age_knn, "Age: kNN")
plot_age_mice <- create_plot(imputed_data, Age, Age_mice, "Age: mice")
plot_age_rpart <- create_plot(imputed_data, Age, Age_rpart, "Age: rpart")

plot_attrition_knn <- create_plot(imputed_data, Attrition, Attrition_knn, "Attrition: kNN")
plot_attrition_mice <- create_plot(imputed_data, Attrition, Attrition_mice, "Attrition: mice")
plot_attrition_rpart <- create_plot(imputed_data, Attrition, Attrition_rpart, "Attrition: rpart")

plot_income_knn <- create_plot(imputed_data, MonthlyIncome, MonthlyIncome_knn, "MonthlyIncome: kNN")
plot_income_mice <- create_plot(imputed_data, MonthlyIncome, MonthlyIncome_mice, "MonthlyIncome: mice")
plot_income_rpart <- create_plot(imputed_data, MonthlyIncome, MonthlyIncome_rpart, "MonthlyIncome: rpart")

plot_ncw_knn <- create_plot(imputed_data, NumCompaniesWorked, NumCompaniesWorked_knn, "NumCompaniesWorked: kNN")
plot_ncw_mice <- create_plot(imputed_data, NumCompaniesWorked, NumCompaniesWorked_mice, "NumCompaniesWorked: mice")
plot_ncw_rpart <- create_plot(imputed_data, NumCompaniesWorked, NumCompaniesWorked_rpart, "NumCompaniesWorked: rpart")

combined_age_plots <- patchwork::wrap_plots(plot_age_knn, plot_age_mice, plot_age_rpart, nrow = 1)
combined_attrition_plots <- patchwork::wrap_plots(plot_attrition_knn, plot_attrition_mice, plot_attrition_rpart, nrow = 1)
combined_income_plots <- patchwork::wrap_plots(plot_income_knn, plot_income_mice, plot_income_rpart, nrow = 1)
combined_ncw_plots <- patchwork::wrap_plots(plot_ncw_knn, plot_ncw_mice, plot_ncw_rpart, nrow = 1)
```

### 3.4. Porównianie metod imputacji dla poszczególnych zmiennych

#### 3.4.1. Imputacja zmiennej Age

```{r imp_age, echo=TRUE, message=FALSE, warning=FALSE}
print(combined_age_plots)
```

#### 3.4.1. Imputacja zmiennej Attrition

```{r imp_att, echo=TRUE, message=FALSE, warning=FALSE}
print(combined_attrition_plots)
```

#### 3.4.1. Imputacja zmiennej MonthlyIncome

```{r imp_moi, echo=TRUE, message=FALSE, warning=FALSE}
print(combined_income_plots)
```

#### 3.4.1. Imputacja zmiennej NumCompaniesWorked

```{r imp_ncw, echo=TRUE, message=FALSE, warning=FALSE}
print(combined_ncw_plots)
```

### 3.5. Uzupełnianie braków danych

Na podstawie wizualnej oceny rozkładu zmiennych oryginalnych względem imputowanych przy wykorzystaniu metod **kNN**, **mice** oraz **rpart**, jak również biorąc pod uwagę typ braków MCAR i zaobserwowanych w rodziale 2.3. zależności, uznano, iż wypełnienie braków zmiennych wykonane zostanie odpowiednio dla zmiennych:

-   **Age** - metodą mice, jako uwzględniającej najlepiej uwzględniającej silne zalezności z niektórymi zmiennymi, oraz dającej wartości najbardziej zbliżone do wartości na wykresie rozrzutu;
- **Attrition** - metodą rpart, jako najbardziej zbliżoną do oryginalnego rozkładu, gdyż najlepiej radzi sobie ze słabymi i nieliniowmi zależnościami;
- **MonthlyIncome** - metodą mice, z tych samych powodów, dla których wybrano tą metodę do zmiennej **Age**;
- **NumCompaniesWorked** - metodą kNN, gdyż cechuje się ona najbardziej zbliżonym rozkładem do originalnego, a sama zmienna nie wykazywała szczególnej zależności od innych zmienych.

```{r imputacja_fin, eval=FALSE, include=FALSE}
HR_imputowane <- numeric_HR %>%
  mutate(
    Age = as.numeric(imputed_data$Age_mice),
    Attrition = as.numeric(imputed_data$Attrition_rpart),
    MonthlyIncome = as.numeric(imputed_data$MonthlyIncome_mice),
    NumCompaniesWorked = as.numeric(imputed_data$NumCompaniesWorked_knn)
  ) %>%
  mutate(
    # przy rekodowaniu wartości kategorialnych na numeric, jeżeli wartości "zaczynały się od 0", nastąpiło przesuniecie o 1
    # poniższy kod naprawia to
    Attrition = Attrition - 1,
    Gender = Gender - 1,
    BusinessTravel = BusinessTravel - 1,
    OverTime = OverTime - 1,
    StockOptionLevel = StockOptionLevel - 1
  ) %>%
  mutate(
    # Zmienne kategorialne nieuporządkowane
    Department = factor(Department, levels = 1:3, labels = c("Kadry", "Badania i Rozwój", "Sprzedaż"), ordered = FALSE),
    EducationField = factor(EducationField, levels = 1:6, labels = c("Zarządzanie Zasobami Ludzkimi", "Nauki Przyrodnicze", "Marketing", "Medyczne", "Techniczne", "Inne"), ordered = FALSE),
    Gender = factor(Gender, levels = 0:1, labels = c("Kobieta", "Mężczyzna"), ordered = FALSE),
    JobRole = factor(JobRole, levels = 1:9, labels = c("Przedstawiciel Medyczny", "Pracownik Działu Kadr", "Technik Laboratoryjny", "Menedżer", "Dyrektor Produkcji", "Dyrektor Badań", "Pracownik Działu Badań", "Dyrektor Sprzedaży", "Przedstawiciel Handlowy"), ordered = FALSE),
    MaritalStatus = factor(MaritalStatus, levels = 1:3, labels = c("Panna/Kawaler", "Żonata/y", "Rozwiedziona/y"), ordered = FALSE),
    
    # Zmienne kategorialne uporządkowane
    Attrition = factor(Attrition, levels = 0:1, labels = c("Nie", "Tak"), ordered = TRUE),
    BusinessTravel = factor(BusinessTravel, levels = 0:2, labels = c("Brak", "Rzadko", "Często"), ordered = TRUE),
    OverTime = factor(OverTime, levels = 0:1, labels = c("Nie", "Tak"), ordered = TRUE),
    
    # Zmienne kategorialne uporządkowane
    Education = factor(Education, levels = 1:5, labels = c("Średnie i niższe", "Policealne (techniczne)", "Licencjat", "Magister", "Doktor"), ordered = TRUE),
    EnvironmentSatisfaction = factor(EnvironmentSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    JobInvolvement = factor(JobInvolvement, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    JobLevel = factor(JobLevel, levels = 1:5, labels = c("Najniższy", "Niski", "Średni", "Wysoki", "Najwyższy"), ordered = TRUE),
    JobSatisfaction = factor(JobSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    PerformanceRating = factor(PerformanceRating, levels = 1:4, labels = c("Niska", "Dobra", "Znakomita", "Wybitna"), ordered = TRUE),
    RelationshipSatisfaction = factor(RelationshipSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    WorkLifeBalance = factor(WorkLifeBalance, levels = 1:4, labels = c("Zła", "Przeciętna", "Dobra", "Świetna"), ordered = TRUE),
    StockOptionLevel = factor(StockOptionLevel, levels = 0:3, labels = c("Brak", "Niski", "Średni", "Wysoki"), ordered = TRUE)
  )

HR_fin <- HR_imputowane %>%
  clean_names()
```

```{r compare_clean_imputowane, echo=TRUE, message=FALSE, warning=FALSE}
vis_compare(HR_czyste, HR_imputowane)
```

Zauważyć mozemy, iż imputacja danych powiodła się. Zmienne posiadają ten sam typ zmiennych, różnice występują wyłącznie w wartościach, które zostały uzupełnione względem wstępnie oczyszczonych danych `HR_clean`.

