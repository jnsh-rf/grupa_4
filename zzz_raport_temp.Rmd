---
title: "Analiza danych - projekt zespołowy - HR"
#subtitle: "Czyszczenie danych"
author: "Gwozdowski, Itrych, Gawryszczak"
date: Opublikowano `r format(Sys.time(), "%A %d %B %Y")`
output:
  rmdformats::robobook:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: false
    highlight: "tango"
    number_sections: true
    fig_caption: true
    toc_depth: 3
editor_options: 
  markdown: 
    wrap: 120
fontsize: 12pt
---

```{r setup, message = FALSE, warning = FALSE, include = FALSE}
options(scipen = 999, digits=6)
# mirror na Politechnice Warszawskiej
# info z tej strony https://cran.r-project.org/mirrors.html
options(repos = c(CRAN = "https://cran.mi2.ai/"))


# gwarantuje jednakowe wyniki za każdym razem
set.seed(42)


# Lista bibliotek
libraries <- c(
  "rmdformats", "naniar", "visdat", "viridisLite", "ggthemes", "ggrepel",
  "VIM", "simputation", "RColorBrewer", "paletteer", "readr", "dlookr", 
  "Information", "knitr", "hexbin", "readr", "tidyverse", "rstatix", "corrr", 
  "ggcorrplot", "hrbrthemes", "kableExtra", "DT", "mice", "finalfit", "skimr",
  "gridExtra", "caret", "janitor", "summarytools", "ggstatsplot", "viridisLite",
  "gt", "gtsummary", "gtExtras"
  #"modelsummary", "broom", "broom.mixed" # na wypadek budowy modeli
  
  #, "tidylog", # "gt", "ggforce", "gtsummary"
)

packages <- c("skimr", "GGally", "plotly", "randomForest", "e1071", "rpart", "xgboost", "h2o", "rpart.plot", "corrgram", "lightgbm", "psych", "scales", "treemap", "treemapify", "repr", "cowplot", "magrittr", "ggpubr", "plotrix", "forcats", "caTools", "tree", "rattle")

# Funkcja do instalacji i wczytania bibliotek
install_and_load <- function(lib) {
  if (!require(lib, character.only = TRUE)) {
    install.packages(lib, dependencies = TRUE)
    suppressMessages(library(lib, character.only = TRUE))
  }
}

# Iteracja przez listę bibliotek
invisible(sapply(libraries, function(lib) {
  if (lib == "ggplot2") {
    options(device = "null")
    install_and_load(lib)
    options(device = "default")
  } else {
    install_and_load(lib)
  }
}))
```

```{r dane___hide, message=FALSE, warning=FALSE, include=FALSE}
HR <- read_csv("HR.csv")
```

## Odejścia pracowników

Odejścia pracowników prowadzą do znaczących kosztów dla firmy poprzez zakłócenia w działalności, konieczność rekrutacji
i szkolenia nowych pracowników. Dlatego też, dział HR stara się zrozumieć czynniki, które wpływają na odejścia
pracowników, aby skutecznie je minimalizować. Problem odejść pracowników jest złożonym wyzwaniem, które wymaga
zaawansowanego podejścia w zarządzaniu zasobami ludzkimi. Celem projektu jest przewidywanie, którzy pracownicy mogą
zdecydować się na odejście z organizacji, aby odpowiednio wcześniej podjąć działania prewencyjne.

Analityka w tym przypadku odgrywa kluczową rolę w interpretacji danych organizacyjnych. Dzięki analizie danych można
dostrzec ukryte wzorce i trendy związane z pracownikami, umożliwiając podjęcie odpowiednich działań, które przyczynią
się do poprawy efektywności organizacji i zmniejszenia kosztów. Niniejsze badanie eksploacyjne przeprowadzono na
zestawie danych pochodzącym z działu HR.

## Opis i struktura danych

```{r dane_tabela, echo=FALSE, paged.print=TRUE}
#DT::datatable(HR, 
#              options = list(
#                dom = 'ltipr',  # Hide search bar, keep length menu & pagination
#                pageLength = 10, # Default rows displayed
#                lengthMenu = c(5, 10, 20, 50), # Dropdown for number of rows
#                scrollX = TRUE   # Enable horizontal scrolling
#              ),
#              rownames = TRUE)  # Hide row numbers

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:::::::::::::::::  NADAL NIE JEST IDEALNIE  ::::::::::::::::::::::::::::::::::::::::::::
#:::::::::::::::::   ALE ZOSTAWIAM W CELU    ::::::::::::::::::::::::::::::::::::::::::::
#:::::::::::::::::      REFERENCYJNYM        ::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

DT::datatable(
  HR,
  options = list(
    dom = 'ltipr',  # Hide search bar, keep length menu & pagination
    pageLength = 10,  # Default rows displayed
    lengthMenu = c(5, 10, 20, 50),  # Dropdown for number of rows
    scrollX = TRUE,  # Enable horizontal scrolling
    fixedColumns = list(leftColumns = 1),  # Fix the first column when scrolling
    rownames = TRUE,  # Show row names
    columnDefs = list(
      list(targets = "_all", render = JS(
        "function(data, type, row, meta) {",
        "  if (data === null || data === '') { return 'NA'; }",
        "  return data;",
        "}"))
    )  # Display NA in a more explicit way
  ),
  rownames = TRUE  # Explicitly ensure row names are visible
)
```

Zbiór danych `HR` zawiera informacje dotyczące 1,470 obecnych i byłych pracowników zebranych w 35 kolumnach, w tym
związane z ich satysfakcją z pracy, równowagą między życiem zawodowym a prywatnym, stażem pracy, doświadczeniem,
wynagrodzeniem oraz innych cech demograficznych.

```{r stat_op_brudne, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}
skim(HR)
```

## Sprawdzenie spójności danych

Spójne dane to technicznie poprawne dane, które nadają się do analizy statystycznej. Są to dane, w których brakujące
wartości, wartości specjalne, (oczywiste) błędy i wartości odstające zostały usunięte, skorygowane lub przypisane. Dane
są zgodne z ograniczeniami opartymi na rzeczywistej wiedzy na temat przedmiotu, który dane opisują.

### Walidacja danych

Przed przystąpieniem do dalszej analizy danych, niezwykle istotne jest upewnienie się, że dane spełniają określone
założenia w celu zapewnienia ich poprawności i spójności. Poniżej przedstawiono kluczowe założenia, które należy
zweryfikować przed rozpoczęciem właściwej analizy danych:

-   zmienne numeryczne w zestawie danych powinny przyjmować wyłącznie wartości nieujemne;
-   pracownicy spełniają wymagania związane z pełnoletnością, wiekiem emerytalnym oraz z dotychczasowym stażem pracy;
-   zmienna dotycząca odejść pracowników powinna ona przyjmować jedynie dwie kategorie: „Yes” dla osób, które opuściły
    firmę, oraz „No” dla pracowników pozostających w firmie;
-   w przypadku pracowników, dla których ta firma nie była pierwszym pracodawcą, konieczne jest odpowiednie odnotowanie
    tej informacji;
-   szkolenia pracowników odbywają się nie częściej, niż co dwa miesiące;
-   czas przeprawcowany w firmie może być krótszy niż czas od ostatniego awansu, lata pracy z tym samym menedżerem lub
    lata na obecnym stanowisku;
-   prawidłowo uzależniona wartość podwyżki od oceny pracy pracownika;
-   należycie przypisano sprawowane stanowiska do działów przedsiębiorstwa.

```{r reguly_walidacyjne, message=FALSE, warning=FALSE, include=FALSE}
walidacja_danych <- function(HR) {
  HR %>% mutate(
    AgeRule = if_else(
      Age >= 18 & Age <= 67 & Age >= (18 + TotalWorkingYears) & is.numeric(Age),
      TRUE, 
      FALSE, 
      missing = NA
    ),
    AttritionRule = if_else(
      Attrition %in% c("Yes", "No"),
      TRUE,
      NA, 
      # FALSE, # coś knoci
      missing = NA
    ),
    DistanceFromHomeRule = if_else(
      DistanceFromHome >= 0 & is.numeric(DistanceFromHome), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    DailyRateRule = if_else(
      DailyRate > 0 & is.numeric(DailyRate), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    HourlyRateRule = if_else(
      is.numeric(HourlyRate) & HourlyRate > 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    MonthlyIncomeRule = if_else(
      is.numeric(MonthlyIncome) & MonthlyIncome> 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    MonthlyRateRule = if_else(
      is.numeric(MonthlyRate) & MonthlyRate > 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    NumCompaniesWorkedRule = if_else(
      is.numeric(NumCompaniesWorked) & 
      (
        NumCompaniesWorked > 0 | (NumCompaniesWorked == 0 & YearsAtCompany == TotalWorkingYears)
      ), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    TotalWorkingYearsRule = if_else(
      is.numeric(TotalWorkingYears) & TotalWorkingYears >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    TrainingTimesLastYearRule = if_else(
      is.numeric(TrainingTimesLastYear) & TrainingTimesLastYear >= 0 & TrainingTimesLastYear <= 6, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsAtCompanyRule = if_else( 
      is.numeric(YearsAtCompany) &
      YearsAtCompany >= 0 & YearsAtCompany <= 49 & (
        (YearsAtCompany >= YearsInCurrentRole) | 
        (YearsAtCompany >= YearsSinceLastPromotion) | 
        (YearsAtCompany >= YearsWithCurrManager)
      ),       TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsInCurrentRoleRule = if_else(
      is.numeric(YearsInCurrentRole) & YearsInCurrentRole >= 0 & YearsInCurrentRole < 49, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsSinceLastPromotionRule = if_else(
      is.numeric(YearsSinceLastPromotion) & YearsSinceLastPromotion >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsWithCurrManagerRule = if_else(
      is.numeric(YearsWithCurrManager) & YearsWithCurrManager >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    PercentSalaryHikeRule = if_else(
      (PerformanceRating == 1 & PercentSalaryHike == 0) |
      (PerformanceRating == 2 & PercentSalaryHike >= 1 & PercentSalaryHike <= 10) |
      (PerformanceRating == 3 & PercentSalaryHike >= 11 & PercentSalaryHike <= 19) |
      (PerformanceRating == 4 & PercentSalaryHike >= 20), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    JobRoleRule = if_else(
      (Department == "Sales" & JobRole %in% c("Sales Executive", "Sales Representative", "Manager")) |
      (Department == "Research & Development" & JobRole %in% c("Research Scientist", "Laboratory Technician", 
                                                                 "Research Director", "Manufacturing Director", 
                                                                 "Healthcare Representative", "Manager")) |
      (Department == "Human Resources" & JobRole %in% c("Human Resources", "Manager")), 
      TRUE, 
      FALSE, 
      missing = NA
    )
  )
}
```

```{r wyniki_walidacji___hide, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
podsumowanie_walidacji <- walidacja_danych(HR) %>%
  select(ends_with("Rule")) %>%
  mutate(across(everything(), ~ case_when(
    is.na(.) ~ "NA",
    . == TRUE ~ "Pass",
    . == FALSE ~ "Fail"
  ), .names = "Status_{.col}")) %>%
  pivot_longer(
    cols = starts_with("Status_"),
    names_to = "Rule",
    values_to = "Status",
    names_prefix = "Status_"
  )

wykres_walidacja <- podsumowanie_walidacji %>%
  group_by(Rule, Status) %>%
  summarize(Count = n(), .groups = "drop") %>%
  mutate(Rule = gsub("Rule$", "", Rule)) %>%
  pivot_wider(names_from = Status, values_from = Count, values_fill = list(Count = 0))

wykres_walidacja_fin <- wykres_walidacja %>%
  pivot_longer(cols = -Rule, names_to = "Status", values_to = "Count")

wykres_walidacja_legenda <- wykres_walidacja_fin %>%
  mutate(total_count = sum(Count)) %>%
  group_by(Status) %>%
  mutate(Percentage = sum(Count) / total_count * 100) %>%
  summarize(Percentage = unique(Percentage)) %>%
  ungroup() %>%
  mutate(Label = paste0(Status, sprintf(" (%.1f%%)", Percentage))) %>%
  pull(Label)

# zmienić poniższe gdy dojdzie do renderu
walidacja_rezultat <- wykres_walidacja %>%
  mutate(
    Total = `Fail` + `Pass` + `NA`,
    `Fail %` = sprintf("%.1f%%", (`Fail` / Total) * 100),
    `Pass %` = sprintf("%.1f%%", (`Pass` / Total) * 100),
    `NA %` = sprintf("%.1f%%", (`NA` / Total) * 100)
  ) %>%
  select(Rule, `N Passed` = Pass, `N Failed` = Fail, `N NA` = `NA`, `Fail %`, `Pass %`, `NA %`) %>%
  kable("html", escape = FALSE, align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

kolory_walidacja <- c("Fail" = "#FB9A99", "Pass" = "#B2DF8A", "NA" = "#FDBF6F")
```

```{r wyniki_walidacja_wykres, echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
ggplot(wykres_walidacja_fin, aes(x = Rule, y = Count, fill = Status)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = kolory_walidacja, labels = wykres_walidacja_legenda) +
  theme_minimal() +
  coord_flip() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "bottom",
    legend.justification = "right",
    legend.title = element_blank(),
    plot.title = element_blank()
  )
```

```{r wyniki_walidacji_rezultat, message=FALSE, warning=FALSE, paged.print=FALSE}
walidacja_rezultat
```

zauważyć możemy następujące problemy : występują braki (szerzej poniżej) oraz liczba firm w której ktos pracował
wcześniej (to w dalszym kroku),

co przedstawia poniższy wykres

### Struktura danych / Wykrywanie braków danych

```{r str_danych, echo=TRUE}
glimpse(HR)

invisible(n_miss(HR))
invisible(prop_miss(HR))
brak_wart <- tibble(miss_var_summary(HR))
brak_wart
miss_case_table(HR)

```

Zbiór składa się z 1470 obserwacji (wierszy) oraz 35 zmiennych (kolumn). W tym zbiorze danych mamy tylko dwa typy
danych: ***numeric*** oraz ***character***.

W zbiorze danych brakuje 400 zmiennych, co stanowi 0,7774% wszystkich zmiennych. 331 rzedów cechuje się brakiem jednej
ze zmiennych, 33 rzedy dwoma brakami oraz w 1 rzędzie brakuje wartości dla 3 zmiennych.

Przewidywane odejście pracowników **Attrition** stanowić będą zmienną objaśnianą. Ze względu na fakt, iż jest to zmienna
typu ***character***, w dalszych krokach przekodowana zostanie ona na zmienną typu ***factor***.

### Statystyki opisowe - dokonczyc !!!

```{r stat_op_HR, eval=FALSE, include=FALSE}
summary(HR[, sapply(HR, is.numeric)])
stop_hr
```

## Wizualizacja braku danych

Graficzna prezentacja braku danych pozwala nam okreslić rozkład brakujących zmiennych, oraz wstępnie ocenić typ braku
danych, przydatny do podjęcia następnych kroków.

```{r viz_do_rozdzielenia, echo=TRUE}
vis_miss(HR)
vis_dat(HR)
#zgrupowane po wierszach z brakami i uporządkowanie kolumn w kolejności brakujących
vis_miss(HR, cluster = TRUE, sort_miss = TRUE)
gg_miss_fct(HR, fct = JobSatisfaction)
#wizualizacja współwystępowania braków, brakuje w 3 kolumnach, stąd nsets = 3
gg_miss_upset(HR, nsets = 3)
# pakiet finalfit
explain <- names(HR)
missplot_complete <- HR %>% missing_pattern("Age", explain)
# na tep odstawie usunieto wszystki zmienne za wyjątkiem YearsWithCurrManager, JobRole i Gender oraz zmiennych z brakami
explain_u <- c("Age", "Attrition", "MonthlyIncome", "Gender", "JobRole", "YearsWithCurrManager")
missplot_finalfit <- HR %>% missing_pattern("Age", explain_u)
```

Na podstawie graficznej przezentacji braków danych możemy zauważyć, iż braki danych w zmiennych współwystępują w:

-   Age i Attrition 12 razy;
-   Attrition i MonthlyIncome 12 razy;
-   Age i MonthlyIncome 9 razy;
-   wszystkich razem tylko 1 raz.

Zauważyć możemy również grupowanie się braków danych. Braki przyjmują wzorzec wielowymiarowy (brak w więcej niż jednej
zmiennej), niemonotonny (braki jedej zmiennej nie oznaczają braków pozostałych zmiennych) oraz połączony.

```{r kor_brak_old, eval=FALSE, warning=FALSE, include=FALSE}
ggplot(data = HR, aes(x = Age, y = MonthlyIncome)) +
  geom_point() +
  geom_miss_point() +
  scale_color_manual(values = c("darkorange", "cyan4"),
                     aesthetics = c("colour", "fill")) +
  theme_minimal()
```

```{r a_mi_scatter_braki, echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data = HR, aes(x = Age, y = MonthlyIncome)) +
  geom_point() +  # Regular points
  geom_miss_point() + # Highlight missing points
  scale_color_manual(
    name = "brakujące wartości",
    values = c("darkorange", "cyan4"),  # Colors for missing and non-missing
    labels = c("występują", "nie występują")
  ) +
  labs(
    x = "Age",
    y = "MonthlyIncome"
  ) +
  theme_minimal() +
  theme(legend.position = "right")
```

Na powyższym wykresie zobserwować możemy, iż zmienne **MonthlyIncome** oraz **Age** są ze sobą dodatnio skorelowane,
aczkolwiek istotna część obserwacji wykazuje się brakami w tychże zmiennych.

## Macierz korelacji dla zmiennych numerycznych

W tej sekcji dowiemy się, które cechy mają ze sobą dodatnią korelację. To mówi nam, czy istnieje związek między dwiema
zmiennymi. W sekcji korelacji podoba mi się to, że pozwala nam ona lepiej zrozumieć niektóre cechy, z którymi mamy do
czynienia.

### Tworzenie macierzy korelacji

```{r mx_kor_numeric, echo=TRUE, message=FALSE, warning=FALSE}
#sprawdzamy unikatowe wartości zmiennych "tekstowych" - przenieść do osobnego bloku (tymczasowo potrzebny tutaj)
all_char_values <- list(
  val_1 = table(HR$Attrition),
  val_2 = table(HR$BusinessTravel),
  val_3 = table(HR$Department),
  val_4 = table(HR$EducationField),
  val_5 = table(HR$Gender),
  val_6 = table(HR$JobRole),
  val_7 = table(HR$MaritalStatus),
  val_8 = table(HR$Over18),
  val_9 = table(HR$OverTime)
)

# to też trzeba zinputować
#HR_0 <- walidacja_danych(HR) %>%
#  mutate(NumCompaniesWorked = if_else(NumCompaniesWorkedRule == FALSE, NA, NumCompaniesWorked)) %>%
#  select(names(HR))

#uproszczenie listy all_char_values
kategorie <- lapply(all_char_values, names)

HR_factor <- HR %>%
  mutate(
    Attrition = factor(Attrition, levels = kategorie$val_1), 
    BusinessTravel = factor(BusinessTravel, levels = kategorie$val_2),
    Department = factor(Department, levels = kategorie$val_3),
    EducationField = factor(EducationField, levels = kategorie$val_4),
    Gender = factor(Gender, levels = kategorie$val_5),
    JobRole = factor(JobRole, levels = kategorie$val_6),
    MaritalStatus = factor(MaritalStatus, levels = kategorie$val_7),
    Over18 = factor(Over18, levels = kategorie$val_8),
    OverTime = factor(OverTime, levels = kategorie$val_9)
  )
## pózniej naprawić i uproscic kod

numeric_HR <- HR %>%
  mutate(Attrition = factor(if_else(Attrition == "Yes", 1, 
                             if_else(Attrition == "No", 0, NA_real_)))) %>%
  mutate(across(where(is.factor), as.numeric)) %>%  
  select(where(is.numeric))  # Keep only numeric columns

  # cor_mat z pakietu rstatix wymaga by na 
  # remove_constant()


table(HR$Attrition, useNA = c("always"))

macierz_kor_numeric <- cor_mat(
  numeric_HR,
  method = "pearson",
  alternative = "two.sided",
  conf.level = 0.95
)

DT::datatable(macierz_kor_numeric, 
              options = list(
                dom = 'ltipr',  # Hide search bar, keep length menu & pagination
                pageLength = 10, # Default rows displayed
                lengthMenu = c(5, 10, 20, 50), # Dropdown for number of rows
                scrollX = TRUE   # Enable horizontal scrolling
              ),
              rownames = TRUE)  # Hide row numbers
```

Podczas tworzenia macierzy korelacji dla zmiennych numerycznych, uwzględniono dodatkowo zmienną **Attrition**, która
została uprzednio po jej uprzednim przekodowaniu na typ ***factor***, a następnie na ***numeric***, celem zbadania
korelacji tej zmiennej z pozostałymi zmiennymi numerycznymi.

W wyniku obliczeń, w przypadku niektórych zmiennych, nie została obliczona wartość współczynnika korelacji. Wynika to z
zastosowanej metody obliczeń, tj. współczynnika korelacji Pearsona, którego wzór jest następujący:

$$
r = \frac{{}\sum_{i=1}^{n} (x_i - \overline{x})(y_i - \overline{y})}{\sqrt{\sum_{i=1}^{n} (x_i - \overline{x})^2  \sum_{i=1}^{n}(y_i - \overline{y})^2}}
$$

Brak wartości korelacji w takich przypadkach związany jest z sytuacją, w której mianownik równania przyjmuje wartość
zerową. Tego typu sytuacja
ma miejsce, gdy którakolwiek ze zmiennych przyjmuje jedną stałą wartość (brak zmienności), co skutkuje zerową wariancją.
W takich przypadkach
obliczenie współczynnika korelacji staje się niemożliwe, a tym samym zmienne te należy usunąć, gdyż nie wnoszą one
żadnej dodatkowej informacji do dalszej analizy danych.

### Graficzna prezentacja korelacji - okreslenie zmienncyh wykorzystanych do imputacji

```{r echo=TRUE}
ggcorrplot(macierz_kor_numeric,
           insig = "blank",
           lab_size = 3, 
           method="square", 
           colors = c("#4477AA", "white", "#BB4444"), 
           ggtheme=theme_minimal(),
           legend.title = "Korelacja")
```

```{r zn_naj_skor, message=FALSE, warning=FALSE, include=FALSE}
mxkor_missing_var <- macierz_kor_numeric %>%
  column_to_rownames("rowname")

mxkor_age <- mxkor_missing_var %>%
  select(Age) %>%
  na.omit() %>%
  arrange(desc(abs(Age))) %>%
  filter(Age != 1)

mxkor_att <- mxkor_missing_var %>%
  select(Attrition) %>%
  na.omit() %>%
  arrange(desc(abs(Attrition))) %>%
  filter(Attrition != 1)

mxkor_moi <- mxkor_missing_var %>%
  select(MonthlyIncome) %>%
  na.omit() %>%
  arrange(desc(abs(MonthlyIncome))) %>%
  filter(MonthlyIncome != 1)

mxkor_ncw <- mxkor_missing_var %>%
  select(NumCompaniesWorked) %>%
  na.omit() %>%
  arrange(desc(abs(NumCompaniesWorked))) %>%
  filter(NumCompaniesWorked != 1)
```

```{r naj_skor_tabela, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
kor_brak_wart_sort 
  cbind
```

Na podstawie macierzy korelacji możemy stwierdzić, że zmienna **Age** skorelowana jest najsilniej z trzema zmiennymi -
**TotalWorkingYears** (0.68), **JobLevel** (0.51) oraz **MonthlyIncome** (0.49), natomiast **MonthlyIncome** ze
zmiennymi **JobLevel** (0.95), **TotalWorkingYears** (0.77), **YearsAtCompany** (0.51) oraz **Age** (0.49). Możemy je
tym samym uznać za zmienne, wykorzystane do imputacji.

Zmienna **Attrition** natomiast nie jest zbyt mocno skorelowana z żadną ze zmiennych, których to wartości absolutne
znajdują się w przedziale [0,0052 - 0,18]. Przyjmiemy tym samym do imputacji wszystkie możliwe zmienne numeryczne,
pomijając zmienne, w których występują braki.

## Czyszczenie Danych

## Imputacja brakujących danych

Imputacja to proces szacowania lub wyprowadzania wartości dla pól, w których brakuje danych.

### Imputacja metodą drzew losowych (RPART)

```{r rpart, echo=TRUE}
im_age_rpart <- round_half_up(imputate_na(numeric_HR, Age, yvar = c("TotalWorkingYears", "JobLevel", "MonthlyIncome"), method = "rpart"), 0)

nazw_kol_hr <- colnames(numeric_HR) %>% 
  setdiff("Attrition")

#znales sposób na zagniezdzenie nazw_kol_hr w im_att_rpart

writeClipboard(nazw_kol_hr)

im_att_rpart <- round_half_up(imputate_na(numeric_HR, Attrition, 
                                  yvar = c("DailyRate", "DistanceFromHome", "Education", "EmployeeCount",
                                           "EmployeeNumber", "EnvironmentSatisfaction", "HourlyRate",
                                           "JobInvolvement", "JobLevel", "JobSatisfaction", "MonthlyIncome",
                                           "NumCompaniesWorked", "PercentSalaryHike", "PerformanceRating",
                                           "RelationshipSatisfaction", "StandardHours", "StockOptionLevel",
                                           "TotalWorkingYears", "TrainingTimesLastYear","WorkLifeBalance",
                                           "YearsAtCompany", "YearsInCurrentRole", "YearsSinceLastPromotion",
                                           "YearsWithCurrManager"), 
                                  method = "rpart"), 0)

im_moi_rpart <- round_half_up(imputate_na(numeric_HR, MonthlyIncome, yvar = c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age"), method = "rpart"), 0)

im_ncw_rpart <- round_half_up(imputate_na(numeric_HR, NumCompaniesWorked, yvar = c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age"), method = "rpart"), 0)

plot(im_age_rpart)
plot(im_att_rpart)
plot(im_moi_rpart)
```

### Imputacja metodą Multivariate Imputation by Chained Equations (mice)

```{r mice, echo=TRUE}
im_age_mice <- round_half_up(imputate_na(numeric_HR, Age, yvar = c("TotalWorkingYears", "JobLevel", "MonthlyIncome"), method = "mice"), 0)

im_att_mice <- round_half_up(imputate_na(numeric_HR, Attrition, 
                                  yvar = c("DailyRate", "DistanceFromHome", "Education", "EmployeeCount",
                                           "EmployeeNumber", "EnvironmentSatisfaction", "HourlyRate",
                                           "JobInvolvement", "JobLevel", "JobSatisfaction", "MonthlyIncome",
                                           "NumCompaniesWorked", "PercentSalaryHike", "PerformanceRating",
                                           "RelationshipSatisfaction", "StandardHours", "StockOptionLevel",
                                           "TotalWorkingYears", "TrainingTimesLastYear","WorkLifeBalance",
                                           "YearsAtCompany", "YearsInCurrentRole", "YearsSinceLastPromotion",
                                           "YearsWithCurrManager"), 
                                  method = "mice"), 0)

im_moi_mice <- round_half_up(imputate_na(numeric_HR, MonthlyIncome, yvar = c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age"), method = "mice"), 0)

im_ncw_mice <- round_half_up(imputate_na(numeric_HR, NumCompaniesWorked, yvar = c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age"), method = "mice"), 0)

plot(im_age_mice)
plot(im_att_mice)
plot(im_moi_mice)
```

### Imputacja metoda K-najbliższych sąsiadów (KNN)

```{r kNN, echo=TRUE}
hr_knn <- VIM::kNN(numeric_HR)

im_age_knn <- round_half_up(hr_knn$Age, 0)
im_att_knn <- round_half_up(hr_knn$Attrition, 0)
im_moi_knn <- round_half_up(hr_knn$MonthlyIncome, 0)

ggplot() +
  geom_density(data = numeric_HR, aes(x = Age, color = "Original"), size = 1) +
  geom_density(data = hr_knn, aes(x = Age, color = "Imputed"), size = 1, linetype = "dashed") +
  labs(
    title = "Rozkład zmiennej Age",
    x = "Age",
    y = "Density",
    color = "Legend"
  ) +
  theme_minimal()

ggplot() +
  geom_density(data = numeric_HR, aes(x = Attrition, color = "Original"), size = 1) +
  geom_density(data = hr_knn, aes(x = Attrition, color = "Imputed"), size = 1, linetype = "dashed") +
  labs(
    title = "Rozkład zmiennej Attrition",
    x = "Age",
    y = "Density",
    color = "Legend"
  ) +
  theme_minimal()

ggplot() +
  geom_density(data = numeric_HR, aes(x = MonthlyIncome, color = "Original"), size = 1) +
  geom_density(data = hr_knn, aes(x = MonthlyIncome, color = "Imputed"), size = 1, linetype = "dashed") +
  labs(
    title = "Rozkład zmiennej MonthlyIncome",
    x = "Age",
    y = "Density",
    color = "Legend"
  ) +
  theme_minimal()

```

### Uzupełnianie braków danych

Na podstawie wizualnej oceny rozkładu zmiennych oryginalnych względem imputowanych przy wykorzystaniu metod RPART, MICE
oraz KNN, uznano, iż wypełnienie braków zmiennych wykonane zostanie odpowiednio:

-   Age - knn / mice
-   Att - mice i rpart (prawie identyczne), wybór mice (jako zmienna)
-   MOI - knn

**potrzebne dalsze testy sprawdzające, jak zmienne się nadają**

```{r imputacja_fin, echo=TRUE}
HR_imputowane <- HR %>%
  cbind(im_age_mice, im_att_mice, im_moi_knn) %>%
  mutate(
    Age = im_age_mice,
    Attrition = im_att_mice,
    MonthlyIncome = im_moi_knn) %>%
  select(-im_age_mice, im_att_mice, im_moi_knn) %>%
  mutate(Attrition = ifelse(Attrition == 1, "No", 
                            ifelse(Attrition == 2, "Yes", Attrition)))

view(HR_imputowane)
```

```{r janitor, echo=TRUE, message=FALSE, warning=FALSE}
# chunk do finalnej wersji tabeli, ma usuwać zbeden kolumny i naprawiać nazwy - pakietem janitor
# clean_names	Cleans names of an object (usually a data.frame).
# remove_constant	Remove constant columns from a data.frame or matrix.
# 
```
