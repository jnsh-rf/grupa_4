---
title: "Analiza danych - projekt zespołowy - HR"
#subtitle: "Czyszczenie danych"
author: "Gwozdowski, Itrych, Gawryszczak"
date: Opublikowano `r format(Sys.time(), "%A %d %B %Y")`
output:
  rmdformats::robobook:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    highlight: "tango"
    number_sections: false
    fig_caption: true
    toc_depth: 4
    code_folding: "show"
editor_options: 
  markdown: 
    wrap: 120
fontsize: 12pt
---

```{r setup, message = FALSE, warning = FALSE, include = FALSE}
options(scipen = 999, digits=6)
# mirror na Politechnice Warszawskiej
# info z tej strony https://cran.r-project.org/mirrors.html
options(repos = c(CRAN = "https://cran.mi2.ai/"))

# gwarantuje jednakowe wyniki za każdym razem
set.seed(42)

libraries <- c(
  "rmdformats", "naniar", "visdat", "viridisLite", "ggthemes", "ggrepel",
  "VIM", "RColorBrewer", "paletteer", "readr", "dlookr", "rpart",
  "Information", "knitr", "hexbin", "readr", "tidyverse", "rstatix", 
  "corrplot", "hrbrthemes", "kableExtra", "DT", "mice", "finalfit", "skimr",
  "gridExtra", "caret", "janitor", "summarytools", "ggstatsplot", "viridisLite",
  "gt", "gtsummary", "gtExtras", "patchwork", "janitor"
  #"modelsummary", "broom", "broom.mixed" # na wypadek budowy modeli
  
  #, "tidylog", # "gt", "ggforce", "gtsummary"
)

packages <- c("GGally", "plotly", "randomForest", "e1071", "rpart", "xgboost", "h2o", "rpart.plot", "corrgram", "lightgbm", "psych", "scales", "treemap", "treemapify", "repr", "cowplot", "magrittr", "ggpubr", "plotrix", "forcats", "caTools", "tree", "rattle")

# Funkcja do instalacji i wczytania bibliotek
install_and_load <- function(lib) {
  if (!require(lib, character.only = TRUE)) {
    install.packages(lib, dependencies = TRUE)
    suppressMessages(library(lib, character.only = TRUE))
  }
}

# Iteracja przez listę bibliotek
invisible(sapply(libraries, function(lib) {
  if (lib == "ggplot2") {
    options(device = "null")
    install_and_load(lib)
    options(device = "default")
  } else {
    install_and_load(lib)
  }
}))
```

```{r dane___hide, message=FALSE, warning=FALSE, include=FALSE}
HR <- read_csv("HR.csv")
```

## Odejścia pracowników

Odejścia pracowników prowadzą do znaczących kosztów dla firmy poprzez zakłócenia w działalności, konieczność rekrutacji
i szkolenia nowych pracowników. Dlatego też, dział HR stara się zrozumieć czynniki, które wpływają na odejścia
pracowników, aby skutecznie je minimalizować. Problem odejść pracowników jest złożonym wyzwaniem, które
wymagazaawansowanego podejścia w zarządzaniu zasobami ludzkimi. Celem projektu jest przewidywanie, którzy pracownicy
mogązdecydować się na odejście z organizacji, aby odpowiednio wcześniej podjąć działania prewencyjne.

Analityka w tym przypadku odgrywa kluczową rolę w interpretacji danych organizacyjnych. Dzięki analizie danych można
dostrzec ukryte wzorce i trendy związane z pracownikami, umożliwiając podjęcie odpowiednich działań, które przyczynią
się do poprawy efektywności organizacji i zmniejszenia kosztów. Niniejsze badanie eksploacyjne przeprowadzono na
zestawie danych pochodzącym z działu HR.

## 1. Opis i struktura danych

```{r dane_tabela, echo=FALSE, paged.print=TRUE}
HR %>%
  kable("html", caption = "Dane HR") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive")) %>%
  scroll_box(width = "100%", height = "300px") 
```

Zbiór danych `HR` zawiera informacje dotyczące 1,470 obecnych i byłych pracowników zebranych w 35 kolumnach, w tym
związane z ich satysfakcją z pracy, równowagą między życiem zawodowym a prywatnym, stażem pracy, doświadczeniem,
wynagrodzeniem oraz innych cech demograficznych.

```{r stat_op_brudne, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}
skim(HR)
```

Analizując strukturę pliku z danymi, możemy wyciągnąć kilka istotnych wniosków dotyczących zarówno samego zbioru danych,
jak i poszczególnych zmiennych. Każdego pracownika reprezentuje zbiór 35 zmiennych, z których 26 to zmienne numeryczne,
a 9 to zmienne kategoryczne (tekstowe).

W analizowanych danych zauważamy kilka istotnych problemów, które warto uwzględnić w dalszym etapie analizy. Zauważyć
możemy występowanie braków danych trzech zmiennych tj. **Age**, **Attrition** oraz **MonthlyIncome**. Wskazuje to na
konieczność rozważenia metod uzupełniania tych braków, aby uniknąć ich wpływu na wyniki analizy.

Dodatkowo, w przypadku zmiennej **NumCompaniesWorked** wartości równe 0 mogą budzić wątpliwości, ponieważ sugerują, że
pracownik nie posiada doświadczenia zawodowego w innych przedsiębiorstwach, co, zwłaszcza w przypadku starszych
pracowników może być nietypowe. Tego rodzaju wartości należy dokładniej przeanalizować, aby zweryfikować, czy są one
wynikiem błędu w rejestracji danych, czy też stanowią rzeczywisty przypadek (np. brak wcześniejszego zatrudnienia).

## 2. Wstępna analiza danych

### 2.1. Weryfikacja poprawności danych

Przed przystąpieniem do dalszej analizy danych, niezwykle istotne jest upewnienie się, że dane spełniają określone
założenia w celu zapewnienia ich poprawności i spójności. Poniżej przedstawiono kluczowe założenia, które należy
zweryfikować przed rozpoczęciem właściwej analizy danych:

-   zmienne numeryczne w zestawie danych powinny przyjmować wyłącznie wartości nieujemne;
-   pracownicy spełniają wymagania związane z pełnoletnością, wiekiem emerytalnym oraz z dotychczasowym stażem pracy;
-   zmienna dotycząca odejść pracowników powinna ona przyjmować jedynie dwie kategorie: „Yes” dla osób, które opuściły
    firmę, oraz „No” dla pracowników pozostających w firmie;
-   w przypadku pracowników, dla których ta firma nie była pierwszym pracodawcą, konieczne jest odpowiednie odnotowanie
    tej informacji;
-   szkolenia pracowników odbywają się nie częściej, niż co dwa miesiące;
-   czas przepracowany w firmie może być krótszy niż czas od ostatniego awansu, lata pracy z tym samym menedżerem lub
    lata na obecnym stanowisku;
-   prawidłowo uzależniona wartość podwyżki od oceny pracy pracownika;
-   należycie przypisano sprawowane stanowiska do działów przedsiębiorstwa.

```{r reguly_walidacyjne, echo=TRUE, message=FALSE, warning=FALSE}
walidacja_danych <- function(HR) {
  HR %>% mutate(
    AgeRule = if_else(
      Age >= 18 & Age <= 67 & Age >= (18 + TotalWorkingYears) & is.numeric(Age),
      TRUE, 
      FALSE, 
      missing = NA
    ),
    AttritionRule = if_else(
      Attrition %in% c("Yes", "No"),
      TRUE,
      NA,
      missing = NA
    ),
    DistanceFromHomeRule = if_else(
      DistanceFromHome >= 0 & is.numeric(DistanceFromHome), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    DailyRateRule = if_else(
      DailyRate > 0 & is.numeric(DailyRate), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    HourlyRateRule = if_else(
      is.numeric(HourlyRate) & HourlyRate > 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    MonthlyIncomeRule = if_else(
      is.numeric(MonthlyIncome) & MonthlyIncome> 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    MonthlyRateRule = if_else(
      is.numeric(MonthlyRate) & MonthlyRate > 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    NumCompaniesWorkedRule = if_else(
      is.numeric(NumCompaniesWorked) & 
      (
        NumCompaniesWorked > 0 | (NumCompaniesWorked == 0 & YearsAtCompany == TotalWorkingYears)
      ), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    TotalWorkingYearsRule = if_else(
      is.numeric(TotalWorkingYears) & TotalWorkingYears >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    TrainingTimesLastYearRule = if_else(
      is.numeric(TrainingTimesLastYear) & TrainingTimesLastYear >= 0 & TrainingTimesLastYear <= 6, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsAtCompanyRule = if_else( 
      is.numeric(YearsAtCompany) &
      YearsAtCompany >= 0 & YearsAtCompany <= 49 & (
        (YearsAtCompany >= YearsInCurrentRole) | 
        (YearsAtCompany >= YearsSinceLastPromotion) | 
        (YearsAtCompany >= YearsWithCurrManager)
      ),       TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsInCurrentRoleRule = if_else(
      is.numeric(YearsInCurrentRole) & YearsInCurrentRole >= 0 & YearsInCurrentRole < 49, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsSinceLastPromotionRule = if_else(
      is.numeric(YearsSinceLastPromotion) & YearsSinceLastPromotion >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    YearsWithCurrManagerRule = if_else(
      is.numeric(YearsWithCurrManager) & YearsWithCurrManager >= 0, 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    PercentSalaryHikeRule = if_else(
      (PerformanceRating == 1 & PercentSalaryHike == 0) |
      (PerformanceRating == 2 & PercentSalaryHike >= 1 & PercentSalaryHike <= 10) |
      (PerformanceRating == 3 & PercentSalaryHike >= 11 & PercentSalaryHike <= 19) |
      (PerformanceRating == 4 & PercentSalaryHike >= 20), 
      TRUE, 
      FALSE, 
      missing = NA
    ),
    JobRoleRule = if_else(
      (Department == "Sales" & JobRole %in% c("Sales Executive", "Sales Representative", "Manager")) |
      (Department == "Research & Development" & JobRole %in% c("Research Scientist", "Laboratory Technician", 
                                                                 "Research Director", "Manufacturing Director", 
                                                                 "Healthcare Representative", "Manager")) |
      (Department == "Human Resources" & JobRole %in% c("Human Resources", "Manager")), 
      TRUE, 
      FALSE, 
      missing = NA
    )
  )
}
```

```{r wyniki_walidacji___hide, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
podsumowanie_walidacji <- walidacja_danych(HR) %>%
  select(ends_with("Rule")) %>%
  mutate(across(everything(), ~ case_when(
    is.na(.) ~ "NA",
    . == TRUE ~ "Pass",
    . == FALSE ~ "Fail"
  ), .names = "Status_{.col}")) %>%
  pivot_longer(
    cols = starts_with("Status_"),
    names_to = "Rule",
    values_to = "Status",
    names_prefix = "Status_"
  )

wykres_walidacja <- podsumowanie_walidacji %>%
  group_by(Rule, Status) %>%
  summarize(Count = n(), .groups = "drop") %>%
  mutate(Rule = gsub("Rule$", "", Rule)) %>%
  pivot_wider(names_from = Status, values_from = Count, values_fill = list(Count = 0))

wykres_walidacja_fin <- wykres_walidacja %>%
  pivot_longer(cols = -Rule, names_to = "Status", values_to = "Count")

wykres_walidacja_legenda <- wykres_walidacja_fin %>%
  mutate(total_count = sum(Count)) %>%
  group_by(Status) %>%
  mutate(Percentage = sum(Count) / total_count * 100) %>%
  summarize(Percentage = unique(Percentage)) %>%
  ungroup() %>%
  mutate(Label = paste0(Status, sprintf(" (%.1f%%)", Percentage))) %>%
  pull(Label)

# zmienić poniższe gdy dojdzie do renderu
walidacja_rezultat <- wykres_walidacja %>%
  mutate(
    Total = `Fail` + `Pass` + `NA`,
    `Fail %` = sprintf("%.1f%%", (`Fail` / Total) * 100),
    `Pass %` = sprintf("%.1f%%", (`Pass` / Total) * 100),
    `NA %` = sprintf("%.1f%%", (`NA` / Total) * 100)
  ) %>%
  select(Rule, `N Passed` = Pass, `N Failed` = Fail, `N NA` = `NA`, `Fail %`, `Pass %`, `NA %`) %>%
  kable("html", escape = FALSE, align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

kolory_walidacja <- c("Fail" = "#FB9A99", "Pass" = "#B2DF8A", "NA" = "#FDBF6F")
```

```{r wyniki_walidacja_wykres, echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
ggplot(wykres_walidacja_fin, aes(x = Rule, y = Count, fill = Status)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = kolory_walidacja, labels = wykres_walidacja_legenda) +
  theme_minimal() +
  coord_flip() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "bottom",
    legend.justification = "right",
    legend.title = element_blank(),
    plot.title = element_blank()
  )
```

```{r wyniki_walidacji_rezultat, message=FALSE, warning=FALSE, paged.print=FALSE}
walidacja_rezultat
```

Zauważono, że w przypadku zmiennej **NumCompaniesWorked** zarejestrowano 197 pracowników, których dotychczasowy staż
pracy przekraczał czas zatrudnienia w analizowanej organizacji, a jednocześnie zmienna ta przyjmowała wartośc 0 . Tego
rodzaju rozbieżność może wskazywać na błędy w rejestracji danych lub na niezgodność między doświadczeniem zawodowym a
zarejestrowaną historią zatrudnienia w firmie. Aby zapewnić poprawność dalszej analizy zależności pomiędzy odejściem
pracowników a innymi zmiennymi, w przypadku tych rozbieżności zostaną wprowadzone braki, co pozwoli uniknąć
potencjalnego zniekształcenia wyników analizy.

```{r wprowadzenie_braków, echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
HR_ncw <- walidacja_danych(HR) %>%
  mutate(NumCompaniesWorked = if_else(NumCompaniesWorkedRule == FALSE, NA, NumCompaniesWorked))

HR <- HR %>%
  mutate(NumCompaniesWorked = HR_ncw$NumCompaniesWorked)
```

### 2.2. Struktura danych po walidacji

```{r str_danych_glimpse, echo=TRUE}
glimpse(HR)
```

Graficzną prezentację danych prezentuje poniższy wykres. Zauważyć możemy, iż zmienne kategoryczne i numeryczne występują
naprzemiennie, a braki dominują w zmiennych numerycznych.

```{r vis_str_danych, echo=TRUE, message=FALSE, warning=FALSE}
vis_dat(HR, sort_type = FALSE)
```

```{r str_danych_mvs, echo=TRUE}
miss_var_summary(HR)
```

```{r str_danych_mcs, echo=TRUE}
miss_case_table(HR)
```

W zbiorze danych brakuje **`r n_miss(HR)`** wartości zmiennych, co stanowi **`r prop_miss(HR) * 100`%** wszystkich
wartości zmiennych. 441 rzedów cechuje się brakiem jednej ze zmiennych, 72 rzędy dwoma brakami oraz w 4 rzędach brakuje
wartości dla 3 zmiennych.

```{r wart_kategoryczne, echo=TRUE, message=FALSE, warning=FALSE}
unique_values_list <- lapply(HR[, sapply(HR, is.character)], unique)

unique_values_list_padded <- lapply(unique_values_list, function(x) {
  length(x) <- max(sapply(unique_values_list, length))
  return(x)
})

unique_values_df <- as.data.frame(unique_values_list_padded)

colnames(unique_values_df) <- names(unique_values_list)

unique_values_df %>%
  kable("html", caption = "Unikalne wartości tekstowe w kolumnach danych HR") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive")) %>%
  scroll_box(width = "100%", height = "300px")
```

W powyższej ramce danych zawarto unikalne wartości dla każdej kolumny tekstowej, co pozwali na analizę możliwych
odpowiedzi w zmiennych kategorycznych. Stwierdzić należy, iż nie wykryto niekonsekwencji w danych, takich jak różne
formaty zapisu, literówki czy nieoczekiwane wartości, za wyjątkiem zmiennej **Over18**, która przyjmuje tylko jedną
wartość.

```{r wart_kategoryczne_2, echo=TRUE, message=FALSE, warning=FALSE}
limited_numeric_values <- function(df, threshold = 10) {
  numeric_cols <- names(df)[sapply(df, is.numeric) & sapply(df, function(x) n_distinct(x) < threshold)]
  
  if (length(numeric_cols) == 0) return(data.frame())
  
  unique_values_list <- lapply(df[numeric_cols], function(x) sort(unique(x)))
  
  max_length <- max(sapply(unique_values_list, length))
  unique_values_df <- as.data.frame(lapply(unique_values_list, `length<-`, max_length))
  unique_values_df <- unique_values_df[rowSums(!is.na(unique_values_df)) > 0, ]
  
  return(unique_values_df)
}

limited_numeric_values(HR) %>%
  kable("html", caption = "Unikalne wartości dla kolumn numerycznych (poniżej progu)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive")) %>%
  scroll_box(width = "100%", height = "300px")
```

Powyższa ramka prezentuje wartości zmiennych numerycznych posiadających mniej niż 10 unikatowych wartości. Zmienne te
można uznać za zmienne kategoryczne, za wyjątkiem zmiennych **EmployeeCount** oraz **StandardHours** przyjmujących tylko
jedną wartość, oraz **TrainingTimesLastYear**, reprezentującej liczbę odbytych przez pracownika szkoleń w roku
poprzednim, która powinna być traktowana jako zmienna numeryczna.

```{r wart_unikatowe__hide, echo=TRUE, message=FALSE, warning=FALSE}
unique_columns <- function(df) {
  col_names <- names(df)
  unique_cols <- col_names[sapply(df, function(x) {
    is.vector(x) && !any(duplicated(x)) && (!is.numeric(x) || all(x == round(x)))
  })]
  return(unique_cols)
}
```

Zbiór danych zawiera ponadto jedną zmienną **`r paste(unique_columns(HR))`**, która to posiada wyłącznie unikatowe
wartości. Stanowią one unikalne identyfikatory pracownika, które nie wnoszą istotnych informacji dla analizy.

### 2.3. Wizualna identyfikacja braków danych

Analiza graficzna braków danych pozwala na szybkie zidentyfikowanie obszarów, w których występują niekompletne
informacje. Dzięki wizualizacji możliwe jest określenie rozkładu brakujących wartości w poszczególnych zmiennych oraz
dostrzeżenie potencjalnych zależności między nimi. Pozwala to lepiej zrozumieć strukturę danych i ocenić charakter
braków, co warunkować będzie wybór odpowiednich metod imputacji.

#### 2.3.1 Analiza grupowań braków danych

```{r brak_viz_grupa, echo=TRUE, message=FALSE, warning=FALSE}
vis_miss(HR, cluster = TRUE, sort_miss = TRUE)
```

Powyższy wykres przedstawia uporządkowaną strukturę, w której obserwacje o podobnych wzorcach braków są ze sobą
grupowane, co umożliwia lepszą identyfikację występujących zależności, a uporządkowanie kolumn według częstości braków
pozwala na łatwiejsze zlokalizowanie zmiennych z najwyższym odsetkiem brakujących wartości. Na jego podstawie zauważyć
można, że większość braków zmiennych jest niezależna od braków innych zmiennych, tylko nieznaczna część braków
współwystępuje z brakami innych zmiennych.

```{r brak_viz_upset, echo=TRUE, message=FALSE, warning=FALSE}
gg_miss_upset(HR, nsets = 4)
```

Powyższe obserwacje potwierdza wykres typu UpSet, na podstawie którego możemy zauważyć interesujące zależności między
zmiennymi. Wszczególności braki danych w różnych zmiennych występują w następujących kombinacjach:

-   Age i Attrition – 12 przypadków,
-   Age i NumCompaniesWorked - 11 przypadków,
-   Age i MonthlyIncome – 7 przypadków,
-   Age, MonthlyIncome i NumCompaniesWorked – 2 przypadki,
-   Age, Attrition i MonthlyIncome – 2 przypadki,
-   Attrition i NumCompaniesWorked – 16 przypadków,
-   Attrition i MonthlyIncome – 11 przypadków,
-   Attrition, MonthlyIncome i NumCompaniesWorked – 2 przypadki,
-   MothlyIncome i NumCompaniesWorked - 15 przypadków.

```{r brak_viz_pattern}
explain <- names(HR)
missplot_complete <- HR %>% missing_pattern("Age", explain)
```

```{r brak_viz_pattern2}
VIM::aggr(HR, combined = TRUE, sortCombs = FALSE)
```

Zauważyć można, iż powyższe wykresy potwierdzają grupowanie się braków danych. Stwierdzić można, iż braki przyjmują
wzorzec wielowymiarowy (braki w więcej niż jednej zmiennej), niemonotonny (braki jedej zmiennej nie oznaczają braków
pozostałych zmiennych) oraz połączony, gdyż braki nie obejmują całej zmiennej, a tym samym pozwalają na określenie
zależności pomiędzy zmiennymi, w tym korelacji.

Kombinacje braków wartości zmiennych, sugerują iż mogą być one całkowicie losowe (Missing Completely At Random) lub są
zależne od innych zmiennych w zbiorze (Missing At Random), co wskazuje na konieczność zastosowania bardziej
zaawansowanych metod imputacji.

#### 2.3.2. Analiza współwystepowania braków

Wykres rozrzutu zmiennych ciągłych, takich jak **Age** i **MonthlyIncome**, dobrze obrazuje zależności między
obserwacjami, gdyż każda wartość jest unikalnie rozmieszczona na osi, co umożliwia łatwe wykrycie zależności zarówno
pomiędzy brakami danych, jak i samymi danymi.

Natomiast w przypadku zmiennych dyskretnych, takich jak **Attrition** (zmienna binarna) i **NumCompaniesWorked**
(przyjmująca ograniczoną liczbę wartości), wykres rozrzutu charakteryzuje się nakładania się punktów, natomiast inne
typy wykresów nie radzą sobie z prezentacją zależności pomiędzy brakami w wartościach poszczególnych zmiennych.
Zastosowanie wykresów dla tychże zmiennych nie przyniesie tym samym dodatkowych informacji, można jednakże zastosować
**Attrition** do grupowania zmiennych ciągłych, przy czym zmienna **NumCompaniesWorked** posiada zbyt wiele wartości, co
uniemożliwia jej efektywne zastosowanie w tym celu.

```{r brak_viz_a_mi_scatter, echo=TRUE, message=FALSE, warning=FALSE}
ami_sc_viz1 <- ggplot(data = HR, aes(x = Age, y = MonthlyIncome)) +
  geom_point() +
  geom_miss_point() +
  geom_smooth(method = "lm", se = FALSE, na.rm = TRUE, color = "black") +
  scale_color_manual(
    name = "Brakujące wartości",
    values = c("darkorange", "cyan4"),
    labels = c("występują", "nie występują")
  ) +
  labs(
    x = "Age",
    y = "MonthlyIncome"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

ami_sc_viz2 <- ggplot(data = HR, aes(x = Age, y = MonthlyIncome, color = Attrition, group = Attrition)) +     
  geom_point() +     
  geom_miss_point() +     
  geom_smooth(method = "lm", se = FALSE, na.rm = TRUE) +     
  scale_color_paletteer_d("khroma::bright", name = "Attrition", direction = 1, na.value = "black") +  
  labs(x = "Age", y = "MonthlyIncome") +     
  theme_minimal() +     
  theme(legend.position = "bottom")

ami_sc_vizcomb <- wrap_plots(ami_sc_viz1, ami_sc_viz2, nrow = 1)
ami_sc_vizcomb
```

Możemy zauważyć, że zmienne **MonthlyIncome** oraz **Age** wykazują dodatnią korelację – wraz ze wzrostem wieku
miesięczney dochód rośnie. Linia trendu potwierdza tę zależność, sugerując, że starsi pracownicy generalnie osiągają
wyższe dochody. Braki danych co do wieku pracownika (oznaczone na osi pionowej) dotyczą głównie pracowników o niższym i
średnim dochodzie, natomiast braki danych, co do miesięcznego dochodu (oznaczone na osi poziomej) cechują się mniej
więcej równym rozkładem.

Dodatkowo zauważyć należy, iż braki w zmiennych **Age** i **MonthlyIncome** nie wykazują szczególnie wyraźnego
uzależnienia od tego, czy pracownik odszedł z przedsiębiorstwa, natomiast brak danych dotyczących odejść dotyczy głównie
pracowników relatywnie młodszych i o niższym miesięcznym dochodzie.

Warto przy tym zaznaczyć, że metodę regresji liniowej, zastosowano wyłącznie do kompletnych przypadków, co minimalizuje
potencjalne zniekształcenia, jakie mogłyby wyniknąć z uśredniania wartości przy obecności braków.

### 2.4. Test Little'a MCAR (Missing Completely at Random)

W celu sprawdzenia, czy brakujące dane są brakujące całkowicie losowo (MCAR), przeprowadzono test statystyczny, który
ocenia tę hipotezę. Jest to istotne, ponieważ jeśli dane są MCAR, możemy uznać, że brakujące wartości nie wprowadzają
uprzedzeń do analiz i bezpiecznie zastosować metody imputacji braków.

W kontekście wcześniejszych obserwacji wykresów, gdzie mogły pojawić się pewne wstępne sygnały co do charakteru braków
danych, przeprowadzenie testu Little’a MCAR umożliwia statystyczną weryfikację tych obserwacji. Test ten, zaproponowany
przez R. Little’a (1988), służy do sprawdzenia, czy brakujące dane w zbiorze są całkowicie losowe. W praktyce test ten
ocenia, czy wzorce braków danych nie wykazują żadnej systematycznej zależności od wartości obserwowanych (ani
nieobserwowanych) zmiennych.

**Hipoteza testu:**

-   **Hipoteza zerowa (H₀)**: Dane są brakujące całkowicie losowo (MCAR). Oznacza to, że brakujące wartości nie mają
    żadnej zależności ani z obserwowanymi, ani z nieobserwowanymi zmiennymi.
-   **Hipoteza alternatywna (H₁)**: Dane nie są brakujące całkowicie losowo, czyli brakujące wartości są powiązane z
    obserwowanymi lub nieobserwowanymi zmiennymi w zbiorze danych.

```{r MCAR_test, echo=TRUE, message=FALSE, warning=FALSE}
HR_mcar_test <- HR %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(across(where(is.factor), ~ as.numeric(.))) %>%
  remove_constant()
mcar_test(HR_mcar_test)
```

**Interpretacja:**

-   **Wartość p = 0,109** (większa od typowego poziomu istotności 0,05) wskazuje, że nie ma wystarczających dowodów, aby
    odrzucić hipotezę zerową (H₀). Oznacza to, że brakujące dane można uznać za **brakujące całkowicie losowo (MCAR)**.
-   **Liczba wzorców brakujących danych** wynosząca 14 wskazuje, że w zbiorze występuje 14 różnych kombinacji zmiennych
    z brakującymi wartościami, co potwierdza wcześniejsze obserwacje.

Wykorzystana metoda w pakiecie `naniar` stanowi implementację testu Little’a MCAR, o której więcej można przeczytać w
oryginalnym artykule:

> Little, R. J. A. (1988). "A Test of Missing Completely at Random for Multivariate Data with Missing Values." *Journal
> of the American Statistical Association*, 83(404), 1198–1202.

### 2.5. Zidentyfikowane problemy w bazie danych

-   Łączna liczba brakujących danych w zbiorze wynosi **r n_miss(HR)**. Konieczne jest tym samym zastosowanie metod
    uzupełnienia braków danych uwzględniających złożony charakter braków danych.
-   Zmienne tekstowe **Department**, **EducationField**, **Gender**, **JobRole** oraz **MaritalStatus** powinny być
    zakodowane jako zmienne kategorialne (***factor***), podczas gdy zmienne tekstowe **Attrition**, **BusinessTravel**,
    **OverTime** oraz numeryczne **Education**, **EnvironmentSatisfaction**, **JobInvolvement**, **JobLevel**,
    **JobSatisfaction**, **PerformanceRating**, **RelationshipSatisfaction**, **StockOptionLevel** oraz
    **WorkLifeBalance**, powinny być uporządkowanymi zmiennymi kategorialnymi (***ordered factor***).
-   Zmienne **EmployeeCount**, **EmployeeNumber**, **StandardHours** oraz **Over18** nie dostarczają nowych informacji
    analitycznych i zostaną usunięte ze zbioru danych.

## 3. Czyszczenie danych

### 3.1. Usuwanie zbędnych kolumn

```{r usuwanie_zb_kol, echo=TRUE, message=FALSE, warning=FALSE}
HR_czyste <- HR %>%
  select(- EmployeeCount, - EmployeeNumber, - StandardHours, - Over18)
```

### 3.2. Przekodowanie zmiennych

Poniższy kod przekształca wskazane w rozdziale 2.5. zmienne na zmienne kategorialne (***factor***) oraz uporządkowene
kategorialne (***ordered factor***) z nadaniem odpowiednich etykiet (***labels***). Jest to standardowa praktyka w w
przygotowaniu danych do analizy statystycznej. Umożliwia to stosowanie różnych metod statystycznych i modeli, oraz
pozwala na łatwą konwersję na zmienne numeryczne, jeżeli jest to wymagane.

```{r przekodowanie_zmiennych, echo=TRUE, message=FALSE, warning=FALSE}
HR_czyste <- HR_czyste %>%
  mutate(
    # Zmienne kategorialne nieuporządkowane (bazowe tekstowe)
    Department = factor(case_when(
      Department == "Human Resources" ~ 1,
      Department == "Research & Development" ~ 2,
      Department == "Sales" ~ 3
    ), levels = 1:3, labels = c("Kadry", "Badania i Rozwój", "Sprzedaż"), ordered = FALSE),

    EducationField = factor(case_when(
      EducationField == "Human Resources" ~ 1,
      EducationField == "Life Sciences" ~ 2,
      EducationField == "Marketing" ~ 3,
      EducationField == "Medical" ~ 4,
      EducationField == "Technical Degree" ~ 5,
      EducationField == "Other" ~ 6
    ), levels = 1:6, labels = c("Zarządzanie Zasobami Ludzkimi", "Nauki Przyrodnicze", "Marketing", "Medyczne", "Techniczne", "Inne"), ordered = FALSE),

    Gender = factor(case_when(
      Gender == "Female" ~ 0,
      Gender == "Male" ~ 1
    ), levels = 0:1, labels = c("Kobieta", "Mężczyzna"), ordered = FALSE),

    JobRole = factor(case_when(
      JobRole == "Healthcare Representative" ~ 1,
      JobRole == "Human Resources" ~ 2,
      JobRole == "Laboratory Technician" ~ 3,
      JobRole == "Manager" ~ 4,
      JobRole == "Manufacturing Director" ~ 5,
      JobRole == "Research Director" ~ 6,
      JobRole == "Research Scientist" ~ 7,
      JobRole == "Sales Executive" ~ 8,
      JobRole == "Sales Representative" ~ 9
    ), levels = 1:9, labels = c("Przedstawiciel Medyczny", "Pracownik Działu Kadr", "Technik Laboratoryjny", "Menedżer", "Dyrektor Produkcji", "Dyrektor Badań", "Pracownik Działu Badań", "Dyrektor Sprzedaży", "Przedstawiciel Handlowy"), ordered = FALSE),

    MaritalStatus = factor(case_when(
      MaritalStatus == "Single" ~ 1,
      MaritalStatus == "Married" ~ 2,
      MaritalStatus == "Divorced" ~ 3
    ), levels = 1:3, labels = c("Panna/Kawaler", "Żonata/y", "Rozwiedziona/y"), ordered = FALSE),

    # Zmienne kategorialne uporządkowane (bazowe tekstowe)
    Attrition = factor(case_when(
      Attrition == "No" ~ 0,
      Attrition == "Yes" ~ 1
    ), levels = 0:1, labels = c("Nie", "Tak"), ordered = TRUE),

    BusinessTravel = factor(case_when(
      BusinessTravel == "Non-Travel" ~ 0,
      BusinessTravel == "Travel_Rarely" ~ 1,
      BusinessTravel == "Travel_Frequently" ~ 2
    ), levels = 0:2, labels = c("Brak", "Rzadko", "Często"), ordered = TRUE),

    OverTime = factor(case_when(
      OverTime == "No" ~ 0,
      OverTime == "Yes" ~ 1
    ), levels = 0:1, labels = c("Nie", "Tak"), ordered = TRUE),

    # Zmienne kategorialne uporządkowane (bazowe numeryczne)
    Education = factor(Education, levels = 1:5, labels = c("Średnie i niższe", "Policealne (techniczne)", "Licencjat", "Magister", "Doktor"), ordered = TRUE),
    EnvironmentSatisfaction = factor(EnvironmentSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    JobInvolvement = factor(JobInvolvement, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    JobLevel = factor(JobLevel, levels = 1:5, labels = c("Najniższy", "Niski", "Średni", "Wysoki", "Najwyższy"), ordered = TRUE),
    JobSatisfaction = factor(JobSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    PerformanceRating = factor(PerformanceRating, levels = 1:4, labels = c("Niska", "Dobra", "Znakomita", "Wybitna"), ordered = TRUE),
    RelationshipSatisfaction = factor(RelationshipSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    WorkLifeBalance = factor(WorkLifeBalance, levels = 1:4, labels = c("Zła", "Przeciętna", "Dobra", "Świetna"), ordered = TRUE),
    StockOptionLevel = factor(StockOptionLevel, levels = 0:3, labels = c("Brak", "Niski", "Średni", "Wysoki"), ordered = TRUE)
  )
```

Graficzną prezentację przekodowanych danych prezentuje poniższy wykres, w celu zwięskzenia czytelności zmienne zostały
pogrupowane po typie zmiennej.

```{r viz_group, echo=TRUE, message=FALSE, warning=FALSE}
visdat::vis_dat(HR_czyste, sort_type = TRUE)
```

### 3.3. Imputacja danych

W analizie danych zbioru HR istotnym etapem przygotowania danych jest uzupełnienie brakujących wartości. Braki danych (w
naszym przypadku `r n_miss(HR_czyste)` wartości) mogą znacząco wpłynąć na wyniki analiz statystycznych i modele
predykcyjne, prowadząc do błędnych wniosków. W związku z tym konieczne jest wdrożenie odpowiednich metod imputacji,
które pozwolą na kompleksowe uzupełnienie braków, a tym samym na zwiększenie wiarygodności dalszych analiz.

Mechanizm braków w naszym zbiorze danych został określony jako MCAR (Missing Completely at Random), co oznacza, że
brakujące dane występują losowo i nie są powiązane z innymi obserwowanymi ani nieobserwowanymi zmiennymi. W celu
uwzględnienia charakteru braku danych oraz typu danych w niniejszym rozdziale zaprezentowane zostaną trzy różne
podejścia do imputacji:

1.  **Metoda k-Najbliższych Sąsiadów** (kNN)**\
    **Metoda kNN (k-Nearest Neighbours) uzupełnia brakujące dane na podstawie podobieństwa obserwacji. Dla każdej
    obserwacji z brakującą wartością wyszukiwani są najbliżsi sąsiedzi (na podstawie innych zmiennych) i wartość
    imputowana jest na podstawie ich danych. Metoda ta jest intuicyjna i dobrze sprawdza się, gdy założymy, że podobne
    obserwacje mają podobne wartości zmiennych.

2.  **Metoda** **Multivariate Imputation by Chained Equations** (mice)**\
    **mice to zaawansowana technika wielokrotnej imputacji, która pozwala na stworzenie kilku kompletnych zbiorów
    danych. Metoda ta polega na iteracyjnym uzupełnianiu brakujących wartości przy użyciu modeli statystycznych, takich
    jak regresja logistyczna dla zmiennych *binarnych* (**Attrition**) oraz *predictive mean matching* (pmm) dla
    zmiennych *ciągłych* (**MonthlyIncome** i **Age**) lub *dyskretnych* (**NumCompaniesWorked**). Dzięki podejściu
    wielokrotnemu jesteśmy w stanie uwzględnić niepewność imputacji, co przekłada się na bardziej wiarygodne oszacowanie
    brakujących danych.

3.  **Metoda drzew decyzyjnych** (rpart) **\
    **Imputacja przy użyciu drzew decyzyjnych (Recursive Partitioning and Regression Trees) polega na budowie modelu
    predykcyjnego dla każdej zmiennej z brakami. Dla zmiennych ciągłych stosowana jest regresja drzew decyzyjnych,
    natomiast dla zmiennych kategorycznych – klasyfikacyjnych. Metoda ta jest szczególnie przydatna, gdy zależności
    między zmiennymi są nieliniowe lub bardziej złożone. Drzewa decyzyjne potrafią wychwycić te zależności, co pozwala
    na precyzyjne uzupełnienie brakujących wartości, nawet gdy dane są kompletne zgodnie z założeniem MCAR.

Kryterium decyzyjnym do wyboru zmiennych, na podstawie których imputowane będą wartości metodami **mice** i **rpart**,
będzie wartość współczynnika korelacji liniowej Pearsona, którego wzór jest następujący:

$$
r_{xy} = \frac{{}\sum_{i=1}^{n} (x_i - \overline{x})(y_i - \overline{y})}{\sqrt{\sum_{i=1}^{n} (x_i - \overline{x})^2  \sum_{i=1}^{n}(y_i - \overline{y})^2}}
$$

Wartość współczynnika korelacji mieści się w przedziale domkniętym [−1, 1]. Im większa jego wartość bezwzględna, tym
silniejsza jest zależność liniowa między zmiennymi. r~xy~ = 0 oznacza brak liniowej zależności między cechami. r~xy~ = 1
oznacza dokładną dodatnią liniową zależność między cechami, natomiast r~xy~ = -1 oznacza dokładną ujemną liniową
zależność między cechami. W celu utworzenia macierzy korelacji zmienne kategorialne przekształcone zostaną na zmienne
numeryczne.

#### 3.3.1. Tworzenie macierzy korelacji

```{r mx_kor_numeric, echo=TRUE, message=FALSE, warning=FALSE, paged.print=TRUE}
numeric_HR <- HR_czyste %>%
  mutate(across(where(is.factor), as.numeric)) %>%  
  select(where(is.numeric))

macierz_kor_numeric <- cor_mat(
  numeric_HR,
  method = "pearson",
  alternative = "two.sided",
  conf.level = 0.95) 

macierz_kor_numeric_mx <- macierz_kor_numeric %>%
  column_to_rownames(var = "rowname") %>%
  as.matrix()

macierz_kor_numeric %>%
  kable("html", caption = "Macierz korelacji dla zmiennych numerycznych") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive")) %>%
  scroll_box(width = "100%", height = "300px")
```

#### 3.3.2. Macierz korelacji zmiennych przed imputacją

```{r kor_viz_preimp, echo=TRUE, message=FALSE, warning=FALSE}
corrplot(
  macierz_kor_numeric_mx,
  method = "color",
  type = "upper",
  col = colorRampPalette(c("#4477AA", "white", "#BB4444"))(200),
  insig = "blank",
  tl.cex  = 0.9
)
```

```{r zn_naj_skor, message=FALSE, warning=FALSE, include=FALSE}
mxkor_missing_var <- macierz_kor_numeric %>%
  column_to_rownames("rowname")

mxkor_age <- mxkor_missing_var %>%
  select(Age) %>%
  na.omit() %>%
  arrange(desc(abs(Age))) %>%
  filter(Age != 1)

mxkor_att <- mxkor_missing_var %>%
  select(Attrition) %>%
  na.omit() %>%
  arrange(desc(abs(Attrition))) %>%
  filter(Attrition != 1)

mxkor_moi <- mxkor_missing_var %>%
  select(MonthlyIncome) %>%
  na.omit() %>%
  arrange(desc(abs(MonthlyIncome))) %>%
  filter(MonthlyIncome != 1)

mxkor_ncw <- mxkor_missing_var %>%
  select(NumCompaniesWorked) %>%
  na.omit() %>%
  arrange(desc(abs(NumCompaniesWorked))) %>%
  filter(NumCompaniesWorked != 1)
```

```{r mxkor_tab, echo=TRUE, message=FALSE, warning=FALSE}
mxkor_age
mxkor_att
mxkor_moi
mxkor_ncw
```

Na podstawie macierzy korelacji zauważamy:

-   zmienna **Age** skorelowana jest najsilniej z trzema zmiennymi - **TotalWorkingYears** (0.68), **JobLevel** (0.51)
    oraz **MonthlyIncome** (0.49);
-   **MonthlyIncome** ze zmiennymi **JobLevel** (0.95), **TotalWorkingYears** (0.77), **YearsAtCompany** (0.51) oraz
    **Age** (0.49);
-   zmienne **Attrition** oraz **NumCompaniesWorked** natomiast nie sa zbyt mocno skorelowana z żadną ze zmiennych,
    których to wartości absolutne znajdują się w przedziale kolejno [0,0052 - 0,24] oraz [0.0067 - 0,30]. Przyjmiemy tym
    samym do imputacji wszystkie możliwe zmienne numeryczne, pomijając zmienne, w których występują braki.

Wybór zmiennych do imputacji prezentuje poniższy kod.

```{r predictors, echo=TRUE, message=FALSE, warning=FALSE}
napdst_Age <- c("TotalWorkingYears", "JobLevel", "MonthlyIncome")
napdst_Attrition <- c("DailyRate", "DistanceFromHome", "Education", "EnvironmentSatisfaction", 
                      "HourlyRate", "JobInvolvement", "JobLevel", "JobSatisfaction", 
                      "PercentSalaryHike", "PerformanceRating", 
                      "RelationshipSatisfaction", "StockOptionLevel", "TotalWorkingYears", 
                      "TrainingTimesLastYear", "WorkLifeBalance", "YearsAtCompany", 
                      "YearsInCurrentRole", "YearsSinceLastPromotion", "YearsWithCurrManager")
napdst_MonthlyIncome <- c("JobLevel", "TotalWorkingYears", "YearsAtCompany", "Age")
napdst_NumCompaniesWorked <- c("DailyRate", "DistanceFromHome", "Education", "EnvironmentSatisfaction", 
                               "HourlyRate", "JobInvolvement", "JobLevel", "JobSatisfaction", 
                               "PercentSalaryHike", "PerformanceRating", 
                               "RelationshipSatisfaction", "StockOptionLevel", "TotalWorkingYears", 
                               "TrainingTimesLastYear", "WorkLifeBalance", "YearsAtCompany", 
                               "YearsInCurrentRole", "YearsSinceLastPromotion", "YearsWithCurrManager")
```

```{r fix_dla_imp__hide, echo=TRUE, message=FALSE, warning=FALSE}
imputed_data <- HR_czyste %>%
  mutate(
    Department = as.numeric(Department),
    EducationField = as.numeric(EducationField),
    Gender = as.numeric(Gender),
    JobRole = as.numeric(JobRole),
    MaritalStatus = as.numeric(MaritalStatus),
    Attrition = as.numeric(Attrition),
    BusinessTravel = as.numeric(BusinessTravel),
    OverTime = as.numeric(OverTime),
    Education = as.numeric(Education),
    EnvironmentSatisfaction = as.numeric(EnvironmentSatisfaction),
    JobInvolvement = as.numeric(JobInvolvement),
    JobLevel = as.numeric(JobLevel),
    JobSatisfaction = as.numeric(JobSatisfaction),
    PerformanceRating = as.numeric(PerformanceRating),
    RelationshipSatisfaction = as.numeric(RelationshipSatisfaction),
    WorkLifeBalance = as.numeric(WorkLifeBalance),
    StockOptionLevel = as.numeric(StockOptionLevel)
  )
imputed_data_c <- imputed_data
```

```{r imputed_data, echo=TRUE, message=FALSE, warning=FALSE}
imputed_data <- imputed_data %>%  
  mutate(
    Age_knn = round_half_up(kNN(imputed_data_c, variable = "Age")$Age),    
    Age_mice = round_half_up(imputate_na(imputed_data_c, xvar = "Age", yvar = napdst_Age, method = "mice", print_flag = FALSE)),    
    Age_rpart = round_half_up(imputate_na(imputed_data_c, xvar = "Age", yvar = napdst_Age, method = "rpart")),
      
    Attrition_knn = round_half_up(kNN(imputed_data_c, variable = "Attrition")$Attrition),    
    Attrition_mice = round_half_up(imputate_na(imputed_data_c, xvar = "Attrition", yvar = napdst_Attrition, method = "mice", print_flag = FALSE)),    
    Attrition_rpart = round_half_up(imputate_na(imputed_data_c, xvar = "Attrition", yvar = napdst_Attrition, method = "rpart")),
    
    MonthlyIncome_knn = round_half_up(kNN(imputed_data_c, variable = "MonthlyIncome")$MonthlyIncome),    
    MonthlyIncome_mice = round_half_up(imputate_na(imputed_data_c, xvar = "MonthlyIncome", yvar = napdst_MonthlyIncome, method = "mice", print_flag = FALSE)),    
    MonthlyIncome_rpart = round_half_up(imputate_na(imputed_data_c, xvar = "MonthlyIncome", yvar = napdst_MonthlyIncome, method = "rpart")),
      
    NumCompaniesWorked_knn = round_half_up(kNN(imputed_data_c, variable = "NumCompaniesWorked")$NumCompaniesWorked),    
    NumCompaniesWorked_mice = round_half_up(imputate_na(imputed_data_c, xvar = "NumCompaniesWorked", yvar = napdst_NumCompaniesWorked, method = "mice", print_flag = FALSE)),    
    NumCompaniesWorked_rpart = round_half_up(imputate_na(imputed_data_c, xvar = "NumCompaniesWorked", yvar = napdst_NumCompaniesWorked, method = "rpart"))
  )
```

```{r imputed_data_viz}
create_plot <- function(data, original, imputed, title) {
  ggplot2::ggplot(data) +
    ggplot2::geom_density(ggplot2::aes(x = {{ original }}), color = "#96d170", alpha = 0.4) + 
    ggplot2::geom_density(ggplot2::aes(x = {{ imputed }}), color = "#cb8873", alpha = 0.4) + 
    ggplot2::labs(title = title, x = "Wartość", y = "Gęstość rozkładu") +
    ggplot2::theme_minimal()
}

plot_age_knn <- create_plot(imputed_data, Age, Age_knn, "Age: kNN")
plot_age_mice <- create_plot(imputed_data, Age, Age_mice, "Age: mice")
plot_age_rpart <- create_plot(imputed_data, Age, Age_rpart, "Age: rpart")

plot_attrition_knn <- create_plot(imputed_data, Attrition, Attrition_knn, "Attrition: kNN")
plot_attrition_mice <- create_plot(imputed_data, Attrition, Attrition_mice, "Attrition: mice")
plot_attrition_rpart <- create_plot(imputed_data, Attrition, Attrition_rpart, "Attrition: rpart")

plot_income_knn <- create_plot(imputed_data, MonthlyIncome, MonthlyIncome_knn, "MonthlyIncome: kNN")
plot_income_mice <- create_plot(imputed_data, MonthlyIncome, MonthlyIncome_mice, "MonthlyIncome: mice")
plot_income_rpart <- create_plot(imputed_data, MonthlyIncome, MonthlyIncome_rpart, "MonthlyIncome: rpart")

plot_ncw_knn <- create_plot(imputed_data, NumCompaniesWorked, NumCompaniesWorked_knn, "NumCompaniesWorked: kNN")
plot_ncw_mice <- create_plot(imputed_data, NumCompaniesWorked, NumCompaniesWorked_mice, "NumCompaniesWorked: mice")
plot_ncw_rpart <- create_plot(imputed_data, NumCompaniesWorked, NumCompaniesWorked_rpart, "NumCompaniesWorked: rpart")

combined_age_plots <- patchwork::wrap_plots(plot_age_knn, plot_age_mice, plot_age_rpart, nrow = 1)
combined_attrition_plots <- patchwork::wrap_plots(plot_attrition_knn, plot_attrition_mice, plot_attrition_rpart, nrow = 1)
combined_income_plots <- patchwork::wrap_plots(plot_income_knn, plot_income_mice, plot_income_rpart, nrow = 1)
combined_ncw_plots <- patchwork::wrap_plots(plot_ncw_knn, plot_ncw_mice, plot_ncw_rpart, nrow = 1)
```

### 3.4. Porównianie metod imputacji dla poszczególnych zmiennych

#### 3.4.1. Imputacja zmiennej Age

```{r imp_age, echo=TRUE, message=FALSE, warning=FALSE}
print(combined_age_plots)
```

#### 3.4.1. Imputacja zmiennej Attrition

```{r imp_att, echo=TRUE, message=FALSE, warning=FALSE}
print(combined_attrition_plots)
```

#### 3.4.1. Imputacja zmiennej MonthlyIncome

```{r imp_moi, echo=TRUE, message=FALSE, warning=FALSE}
print(combined_income_plots)
```

#### 3.4.1. Imputacja zmiennej NumCompaniesWorked

```{r imp_ncw, echo=TRUE, message=FALSE, warning=FALSE}
print(combined_ncw_plots)
```

### 3.5. Uzupełnianie braków danych

Na podstawie wizualnej oceny rozkładu zmiennych oryginalnych względem imputowanych przy wykorzystaniu metod **kNN**,
**mice** oraz **rpart**, jak również biorąc pod uwagę typ braków MCAR i zaobserwowanych w rodziale 2.3. zależności,
uznano, iż wypełnienie braków zmiennych wykonane zostanie odpowiednio dla zmiennych:

-   **Age** - metodą mice, jako uwzględniającej najlepiej uwzględniającej silne zalezności z niektórymi zmiennymi, oraz
    dającej wartości najbardziej zbliżone do wartości na wykresie rozrzutu;
-   **Attrition** - metodą rpart, jako najbardziej zbliżoną do oryginalnego rozkładu, gdyż najlepiej radzi sobie ze
    słabymi i nieliniowmi zależnościami;
-   **MonthlyIncome** - metodą mice, z tych samych powodów, dla których wybrano tą metodę do zmiennej **Age**;
-   **NumCompaniesWorked** - metodą kNN, gdyż cechuje się ona najbardziej zbliżonym rozkładem do originalnego, a sama
    zmienna nie wykazywała szczególnej zależności od innych zmienych.

```{r imputacja_fin, echo=TRUE, message=FALSE, warning=FALSE}
HR_imputowane <- numeric_HR %>%
  mutate(
    Age = as.numeric(imputed_data$Age_mice),
    Attrition = as.numeric(imputed_data$Attrition_rpart),
    MonthlyIncome = as.numeric(imputed_data$MonthlyIncome_mice),
    NumCompaniesWorked = as.numeric(imputed_data$NumCompaniesWorked_knn)
  ) %>%
  mutate(
    # przy rekodowaniu wartości kategorialnych na numeric, jeżeli wartości "zaczynały się od 0", nastąpiło przesuniecie o 1
    # poniższy kod naprawia to
    Attrition = Attrition - 1,
    Gender = Gender - 1,
    BusinessTravel = BusinessTravel - 1,
    OverTime = OverTime - 1,
    StockOptionLevel = StockOptionLevel - 1
  ) %>%
  mutate(
    # Zmienne kategorialne nieuporządkowane
    Department = factor(Department, levels = 1:3, labels = c("Kadry", "Badania i Rozwój", "Sprzedaż"), ordered = FALSE),
    EducationField = factor(EducationField, levels = 1:6, labels = c("Zarządzanie Zasobami Ludzkimi", "Nauki Przyrodnicze", "Marketing", "Medyczne", "Techniczne", "Inne"), ordered = FALSE),
    Gender = factor(Gender, levels = 0:1, labels = c("Kobieta", "Mężczyzna"), ordered = FALSE),
    JobRole = factor(JobRole, levels = 1:9, labels = c("Przedstawiciel Medyczny", "Pracownik Działu Kadr", "Technik Laboratoryjny", "Menedżer", "Dyrektor Produkcji", "Dyrektor Badań", "Pracownik Działu Badań", "Dyrektor Sprzedaży", "Przedstawiciel Handlowy"), ordered = FALSE),
    MaritalStatus = factor(MaritalStatus, levels = 1:3, labels = c("Panna/Kawaler", "Żonata/y", "Rozwiedziona/y"), ordered = FALSE),
    
    # Zmienne kategorialne uporządkowane
    Attrition = factor(Attrition, levels = 0:1, labels = c("Nie", "Tak"), ordered = TRUE),
    BusinessTravel = factor(BusinessTravel, levels = 0:2, labels = c("Brak", "Rzadko", "Często"), ordered = TRUE),
    OverTime = factor(OverTime, levels = 0:1, labels = c("Nie", "Tak"), ordered = TRUE),
    
    # Zmienne kategorialne uporządkowane
    Education = factor(Education, levels = 1:5, labels = c("Średnie i niższe", "Policealne (techniczne)", "Licencjat", "Magister", "Doktor"), ordered = TRUE),
    EnvironmentSatisfaction = factor(EnvironmentSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    JobInvolvement = factor(JobInvolvement, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    JobLevel = factor(JobLevel, levels = 1:5, labels = c("Najniższy", "Niski", "Średni", "Wysoki", "Najwyższy"), ordered = TRUE),
    JobSatisfaction = factor(JobSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    PerformanceRating = factor(PerformanceRating, levels = 1:4, labels = c("Niska", "Dobra", "Znakomita", "Wybitna"), ordered = TRUE),
    RelationshipSatisfaction = factor(RelationshipSatisfaction, levels = 1:4, labels = c("Niskie", "Średnie", "Wysokie", "Bardzo wysokie"), ordered = TRUE),
    WorkLifeBalance = factor(WorkLifeBalance, levels = 1:4, labels = c("Zła", "Przeciętna", "Dobra", "Świetna"), ordered = TRUE),
    StockOptionLevel = factor(StockOptionLevel, levels = 0:3, labels = c("Brak", "Niski", "Średni", "Wysoki"), ordered = TRUE)
  )

HR_final <- HR_imputowane %>%
  clean_names()
```

```{r xyz, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

```

```{r compare_clean_imputowane, echo=TRUE, message=FALSE, warning=FALSE}
visdat::vis_compare(HR_imputowane, HR_czyste)
```

Zauważyć mozemy, iż imputacja danych powiodła się. Zmienne posiadają ten sam typ zmiennych, różnice występują wyłącznie
w wartościach, które zostały uzupełnione względem wstępnie oczyszczonych danych `HR_clean`.

## 4. Analiza wartości odstających

### 4.1 Identyfikacja wartości odstających

W celu sprawdzenia w jakich zmiennych występują wartości odstające zastosowano zdefiniowaną poniżej funcję, aby znaleźć
zmienne zawierające wartości odstające.

```{r ident_kol_wart_odst, message=FALSE, warning=FALSE, include=FALSE}
get_outlier_column_names <- function(data) {
  outlier_indices <- find_outliers(data)
  outlier_columns <- colnames(data)[outlier_indices]
  return(outlier_columns)
}


outlier_columns <- get_outlier_column_names(HR_final)
outlier_columns %>%
  kable("html", caption = "Kolumny z odstającymi wartościami") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
```

Dzięki temu będziemy mogli potem podzielić klientów na tych zarabiających przeciętnie oraz tych, którzy zarabiają
ponadprzecietnie.

```{r outlier_twy_jr, echo=TRUE, message=FALSE, warning=FALSE, paged.print=TRUE}
ggplot(HR_final, aes(x = total_working_years, y = job_role, fill = attrition)) +
    geom_boxplot() +
    labs(x = "Całkowite lata pracy", y = "Stanowisko", title = "Rozkład lat pracy według odejść i pełnionych stanowisk") +
    scale_fill_manual(values = c("Tak" = "salmon", "Nie" = "mediumaquamarine"), name = "Odejście") +
    theme_minimal()
```

## 5. Wizualizacje danych

### 5.1. Relacja pomiędzy zarobkami, wiekiem i odejściami

```{r viz_zar_moi_age_att, echo=TRUE, message=FALSE, warning=FALSE}
ggplot(data = HR_final, aes(x = age, y = monthly_income, color = attrition, group = attrition)) +     
  geom_point() +    
  geom_smooth(method = "lm", se = FALSE, na.rm = TRUE) +     
  scale_color_paletteer_d("khroma::bright", name = "Odejścia", direction = 1, na.value = "black") +  
  labs(x = "Wiek", y = "Miesięczne zarobki", color = "Odejścia") +     
  theme_minimal() +     
  theme(legend.position = "bottom")
```

Możemy zauważyć, że zmienne **monthly_income** oraz **age** wykazują dodatnią korelację – wraz ze wzrostem wieku
miesięczney dochód rośnie. Linia trendu potwierdza tę zależność, sugerując, że starsi pracownicy generalnie osiągają
wyższe dochody. Sugeruje to powiązanie stażu pracy, a tym samym doświadczenia, z wynagrodzeniem.

Dodatkowo zauważyć należy, iż pracownicy, którzy odeszli z firmy są przeciętnie młodsi oraz zarabiali mniej w porównaniu
do pracowników, którzy nie odeszli z przedsiębiorstwa.

### 5.2. Średni miesięczy dochód według stanowiska

```{r vizmeandoch, echo=TRUE, message=FALSE, warning=FALSE}
  HR_final %>%
  select(job_role, monthly_income) %>%
  group_by(job_role) %>%
  summarize(mean = round(mean(monthly_income), 1)) %>%
  ggplot(aes(x = reorder(job_role, -mean), y = mean, fill = mean)) + 
  geom_bar(stat = "identity", width = 0.9, color = "black") +
  geom_text(aes(label = mean), size = 4, vjust = 1.5, color = "#000000") +
  scale_fill_gradient(low = "#c8e9de", high = "#D85F60") +
  theme_minimal() +
  #ggtitle("Średni miesięczny dochód według stanowiska") +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5, size = 16),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 14)
  ) +
  labs(x = "Stanowisko", y = "Miesięczne dochody", fill = "Średnia") +
  scale_y_continuous(labels = scales::comma)
```

Zauważyć można, że najlepiej zarabiającymi pracownikami są osoby na stanowiskach kierowniczych, najmniej zarabiają
natomiast pracownicy najniższego szczebla, zwłaszcza z działów Sprzedaży ora Badań i Rozwoju.

### 5.3. Stan cywilny a odejścia z przedsiebiorstwa

```{r stan_cywil, echo=TRUE, message=FALSE, warning=FALSE}
HR_final %>% group_by(attrition, marital_status) %>% summarize(N = n()) %>% mutate(countT = sum(N)) %>%
  group_by(attrition, marital_status, add=TRUE) %>% mutate(per=paste0(round(100*N/countT,1),'%')) %>% 
  ggplot(aes(x=attrition, y=N, fill=marital_status)) + 
  geom_bar(stat="identity", position=position_dodge()) + 
  theme_minimal() + 
  scale_fill_brewer(palette="Purples") +
  geom_text(aes(label = per), size = 4, vjust = 1.2, color = "black", position = position_dodge(0.9)) + 
  #ggtitle("Stan cywilny a rotacja pracowników") + 
  theme(plot.title = element_text(face = "bold", hjust = 0.5, size = 15)) +
  labs(x = "Odejścia", y = "Liczba pracowników", fill = "Stan cywilny")
```

Zauważyć można, że z pracy najczęściej odchodzą osoby nie będące w związku małżeńskim. Stanowią oni 48,7% wszystkich,
którzy odeszli z przedsiębiorstwa. Najrzadziej odchodzą jednak osoby rozwiedzione (16.4% wszystkich odejść).

Jednocześnie nazleży zauważyć, że zdecydowana większość pracowników pozostających w przedsiębiorstwie jest w związku
małżeńskim, co sugerować może, iż potencjalna niechęć do zmiany miejsca zatrudniania podyktowana jest chęcią zachowania
stabilnego źródła utrzymania gospodarstwa domowego.

### 5.4. Równowaga czasu pracy oraz dział przedsiębiorstwa

```{r dzial_att_a_workbalance, echo=TRUE, message=FALSE, warning=FALSE}
HR_final %>%
  filter(attrition == "Tak") %>%
  select(department, work_life_balance) %>%
  group_by(department, work_life_balance) %>%
  summarize(count = n()) %>%
  ggplot(aes(x = fct_relevel(work_life_balance, "Bardzo dobre", "Dobre", "Średnie", "Złe"), 
             y = count, fill = department)) +
  geom_bar(stat = "identity") +
  facet_wrap(~department) +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_blank(),
    legend.key = element_rect(fill = "white", colour = "black")
  ) +
  scale_fill_manual(values = c("#59e259", "#da5757", "#7979f3")) +
  geom_label(aes(label = count, fill = department), colour = "white", fontface = "italic") +
  labs(
    y = "Liczba pracowników",
    x = "Równowaga pomiędzy życiem prywatnym i zawodowym"
  )
```

Powyższyzy wykres prezntuje liczbę pracowników, który odeszli z przedsiebiorstwa w podziale na dział przedsiebiorstwa
(**department**) oraz na ocenę pracownika co do równowagi między życiem zawodowym a prywatnym (**work_life_balance**).
Zauważyć możemy, iż największą liczbą odejść cechował się Dział Badań i Rozwoju, a najmniejszą Dział Kadr. W kontekście
rodziału 5.2. sugerować to może wpływ relatynie niższych zarobków na odejścia pracowników Działu Badań i Rozwoju,
niewykluczając jednocześnie innych czynników, takich jak aspiracje zawodowe oraz chęć zdobycia nowych umiejętności i
wiedzy, .

Zauważyć można ponadto, iż najczęściej odchodzą pracownicy, którym udaje się pogodzić obowiązki pracownicze z życiem
prywatnym, co sugeruje, że pracownicy nie odchodzą z przedsiębiorstwa ze względu na nadmiar obowiązków lub inne
wymagania związane z czasem pracy, lecz istnieją inne przyczyny.

### 6.3. Analiza opisowa

#### 6.3.1. Statystyki opisowe

```{r finaldesc, echo=TRUE, message=FALSE, warning=FALSE, paged.print=TRUE}
describe(HR_final) %>%
  kable("html", caption = "Statystyki opisowe dla zbioru danych HR") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

#### 6.3.2. Korelacja zmiennych

```{r kor_dla_fin, echo=TRUE, message=FALSE, warning=FALSE, paged.print=TRUE}
numeric_HR_fin <- HR_final %>%
  mutate(across(where(is.factor), as.numeric)) %>%  
  select(where(is.numeric))

macierz_kor_numeric_fin <- cor_mat(
  numeric_HR_fin,
  method = "pearson",
  alternative = "two.sided",
  conf.level = 0.95) 

macierz_kor_numeric_mx_fin <- macierz_kor_numeric_fin %>%
  column_to_rownames(var = "rowname") %>%
  as.matrix()

macierz_kor_numeric_fin %>%
  kable("html", caption = "Macierz korelacji dla zmiennych numerycznych") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "responsive")) %>%
  scroll_box(width = "100%", height = "300px")
```

Otrzymane powyżej wyniki prezentuje poniższa macierz korealacji.

```{r kor_viz_postimp, echo=TRUE, message=FALSE, warning=FALSE}
corrplot(
  macierz_kor_numeric_mx, 
  method = "color", 
  type = "upper", 
  col = colorRampPalette(c("#4477AA", "white", "#BB4444"))(200), 
  insig = "blank", 
  tl.cex = 0.9 )
```

## 6. Wnioskowanie statystyczne

### 6.1. Odejścia z firmy a miesięczny dochód

W kontekście analizy odejść z firmy kluczowe jest określenie, czy wynagrodzenie stanowi czynnik różnicujący pracowników,
którzy pozostali w organizacji, i tych, którzy zdecydowali się na odejście. W tym celu formułujemy następujące hipotezy:

-   **Hipoteza zerowa (H₀):** Nie ma statystycznie istotnej różnicy w wysokości miesięcznego dochodu między
    pracownikami, którzy pozostali w firmie, a tymi, którzy ją opuścili.
-   **Hipoteza alternatywna (H₁):** Istnieje statystycznie istotna różnica w wysokości miesięcznego dochodu między
    pracownikami, którzy pozostali w firmie, a tymi, którzy ją opuścili.

```{r att_a_moi, echo=TRUE, message=FALSE, warning=FALSE}
ggbetweenstats(data = HR_final, x = attrition, y = monthly_income) +
  scale_color_manual(values = c("#219ebc", "#fb8500"))
```

W przeprowadzonej analizie porównano dochód miesięczny (**monthly_income**) między pracownikami, którzy opuścili firmę
(attrition = "Tak"), a tymi, którzy pozostali (attrition = "Nie"). Zastosowano test t-Studenta Welch'a, który wyniósł
t(400,74) = 8,29. Wartość p = 1,70e-15, co wskazuje na istotną statystycznie różnicę w dochodach między osobami, które
nie odeszły i odeszły, tym samym odrzucamy hipotezę zerową.

Średni dochód w grupie "Nie" wynosił 6909,16 USD, a w grupie "Tak" 4685,64 USD, co oznacza, że osoby, które opuściły
firmę, zarabiały średnio o około 20% mniej. Wielkość efektu, mierzona za pomocą współczynnika Hedges'a g = 0,53,
wskazuje na średni efekt tej różnicy.

Wizualizacja wyników na wykresie wiolinowym pokazuje, że w grupie "Nie" rozkład dochodów jest gęstszy i rozciąga się na
wyższe wartości, podczas gdy w grupie "Tak" dochody koncentrują się głównie wokół niższych i średnich wartości, co
sugeruje, że firmę częściej opuszczają osoby z niższymi dochodami.

Podsumowując, test t wykazał istotną różnicę w dochodach miesięcznych, z osobami o wyższych dochodach bardziej skłonnymi
do pozostania w organizacji. Wielkość efektu sugeruje średnią siłę tej zależności.

### 6.2. Satysfakcja z pracy a dział przedsiębiorstwa

Badanie zależności między działem a satysfakcją z pracy jest kluczowe dla zarządzania zasobami ludzkimi i rozwoju
organizacji, ponieważ może ujawnić obszary wymagające interwencji. Niski poziom satysfakcji w niektórych działach może
wskazywać na problemy takie jak złe zarządzanie, niewłaściwa komunikacja, stres czy nieodpowiednia kultura
organizacyjna, co wymaga poprawy warunków pracy poprzez szkolenia menedżerskie czy zmiany organizacyjne. Ponadto,
analiza może pomóc w optymalizacji procesów rekrutacyjnych, kierując pracowników do działów z wyższą satysfakcją, co
pozytywnie wpłynie na ich zaangażowanie. W przypadku wykrycia niższej satysfakcji w określonych działach, firma może
wdrożyć strategię retencyjną, aby zminimalizować rotację i zmniejszyć koszty rekrutacji oraz szkoleń nowych pracowników.
W celu weryfikacji tej zależności formułujemy następujące hipotezy:

-   **Hipoteza zerowa (H₀):** Satysfakcja z pracy nie różni się w zależności od działu w firmie
-   **Hipoteza alternatywna (H₁):** Satysfakcja z pracy różni się w zależności od działu w firmie.

```{r dzia_viz_stz, echo=TRUE, message=FALSE, warning=FALSE}
hrfinal <- HR_final %>% mutate(job_satisfaction = as.numeric(job_satisfaction), department = as.numeric(department))
ggbetweenstats(data = hrfinal, x = department, y = job_satisfaction)
```

W przeprowadzonej analizie badano zależność między działem w firmie a satysfakcją z pracy. Zastosowano test F Welch'a
(F(2,167,47) = 0,52), który nie wykazał istotnej statystycznie różnicy w średniej satysfakcji z pracy pomiędzy działami.
Wartość p = 0,59 jest większa od poziomu 0,05, co sugeruje, że brak jest wystarczających dowodów, by stwierdzić, iż
średnia satysfakcja z pracy różni się istotnie pomiędzy działami.

Średnia satysfakcja z pracy w dziale HR wynosiła 2,60, co wskazuje na stosunkowo niższe wartości w porównaniu z innymi
działami. W dziale Badań i Rozwoju średnia wyniosła 2,73, a w dziale sprzedaży 2,75.

#### 6.3. Lata pracy w przedsiębiorstwie a miesięczny dochód

Analiza zależności między liczbą lat przepracowanych w firmie a miesięcznym dochodem ma istotne znaczenie dla oceny
polityki wynagrodzeń oraz procesów motywacyjnych w organizacji. Zrozumienie tej zależności może pomóc firmie ocenić, czy
wynagrodzenia są adekwatne do doświadczenia pracowników oraz czy firma oferuje odpowiednie zachęty finansowe dla osób,
które pozostają w organizacji przez długi czas.

Wyniki analizy mogą również pomóc w ustaleniu, czy obecna struktura wynagrodzeń motywuje pracowników do długoterminowego
pozostania w firmie, czy też powoduje stagnację. Jeśli istnieje silna korelacja między stażem a wynagrodzeniem, może to
sugerować, że firma stawia na nagradzanie lojalności. Z drugiej strony, brak takiej korelacji może wskazywać, że inne
czynniki, takie jak wyniki indywidualne, negocjacje płacowe lub zmiany w organizacji, mają większy wpływ na wysokość
pensji.

Ponadto, analiza ta może stanowić punkt wyjścia do dalszych badań na temat struktur wynagrodzeń, awansów oraz polityk
motywacyjnych w firmie, które mogą być dostosowane do różnych poziomów doświadczenia pracowników.

-   **Hipoteza zerowa (H₀):** Liczba lat przepracowanych w firmie nie ma wpływu na miesięczny dochód.
-   **Hipoteza alternatywna (H₁):** Liczba lat przepracowanych w firmie ma wpływ na miesięczny dochód.

```{r ggcatterstat, echo=TRUE, message=FALSE, warning=FALSE}
ggscatterstats(data = HR_final, x = years_at_company, y = monthly_income)
```

W przeprowadzonej analizie badano zależność między liczbą lat pracy w firmie (**years_at_company**) a dochodem
miesięcznym (**monthly_income**). Zastosowano test t-Studenta, który wykazał istotną statystycznie korelację (t = 22,65,
p = 1,10e-97), co sugeruje, że istnieje silna zależność między tymi dwiema zmiennymi. Uzyskana wartość p \< 0,05
wskazuje na istotność tego efektu. Współczynnik korelacji Pearsona wyniósł r = 0,51, co wskazuje na umiarkowaną,
dodatnią korelację między liczbą lat pracy a dochodem miesięcznym. Oznacza to, że wraz ze wzrostem liczby lat pracy w
firmie, dochody miesięczne mają tendencję do wzrostu, ale z umiarkowaną siłą.

Na wykresie scatterplot widoczna jest koncentracja punktów w lewym dolnym rogu, co oznacza dużą liczbę osób z krótkim
stażem i niskimi dochodami. Widzimy również osoby z wyższymi dochodami, ale krótkim stażem, szczególnie w górnej części
wykresu. Z kolei brak jest osób z niskimi dochodami przy długim stażu pracy, co sugeruje, że długoletni pracownicy
rzadko mają niskie wynagrodzenie.

Podsumowując, wyniki wskazują na umiarkowaną zależność między stażem a dochodami, z tendencją do wyższych wynagrodzeń w
przypadku dłuższego stażu, ale także niskimi dochodami w przypadku stażu do 10 lat.

#### 6.4. Delegacje a odejścia z firmy

Analiza wpływu podróży służbowych na odejścia z firmy może dostarczyć istotnych informacji o tym, jak organizacja
zarządza pracownikami, którzy regularnie podróżują służbowo. Jeśli wykryjemy istotną różnicę w liczbie odejść między
pracownikami podróżującymi często a tymi, którzy nie podróżują wcale, firma może podjąć działania mające na celu poprawę
warunków pracy, np. poprzez wprowadzenie elastyczniejszych godzin pracy, lepszą równowagę między życiem prywatnym a
zawodowym, czy dodatkowe benefity dla osób podróżujących.

-   **Hipoteza zerowa (H₀):** Rodzaj podróży służbowych nie ma wpływu na decyzję o odejściu z firmy.
-   **Hipoteza alternatywna (H₁):**Rodzaj podróży służbowych ma wpływ na decyzję o odejściu z firmy.

```{r 65, echo=TRUE, message=FALSE, warning=FALSE}
ggpiestats(data = HR_final, x = business_travel, y = attrition) +
  scale_fill_manual(values = c("#669bbc", "#c1121f", "#fdf0d5")) +
  theme_minimal()
```

W przeprowadzonej analizie badano zależność między częstotliwością delegacji (BusinessTravel) a odstąpieniem od pracy
(Attrition). Test Chi-kwadrat Pearsona (χ² = 20,75, df = 2, p = 3,11e-05) wykazał istotną statystycznie zależność między
tymi zmiennymi, co sugeruje, że częstotliwość delegacji ma związek z decyzją o odejściu z firmy. Wynik p \< 0,05
potwierdza istotność tej zależności.

Przedział ufności 95% (CI = [0,05; 0,16]) wskazuje, że siła tej zależności jest umiarkowana, a wartość współczynnika
Cramera wskazuje na średnią wielkość efektu.

Na wykresie kołowym dla osób, które pozostały w firmie (Attrition = "Nie"), widoczna jest dominacja osób podróżujących
rzadko (72%), z 17% osób podróżujących często i 11% niepodróżujących. Z kolei w grupie osób, które odeszły z firmy
(Attrition = "Tak"), widać, że większość pracowników podróżuje rzadko (65%), ale w tej grupie jest wyższy odsetek osób
podróżujących często (29%), a tylko 6% nie podróżuje w ogóle.

Wyniki sugerują, że osoby, które rzadziej podróżują służbowo, mają tendencję do pozostawania w firmie. Jednak w grupie
osób, które odeszły, znaczny odsetek podróżujących często wskazuje, że intensywność delegacji może wpływać na decyzję o
rotacji, być może wskazując na negatywne skutki częstych wyjazdów służbowych dla lojalności wobec firmy.

## 7. Podsumowanie

W niniejszym raporcie przeprowadzono kompleksowy proces przygotowania i analizy danych, który rozpoczęto od wstępnej
analizy, pozwalającej na identyfikację problemów związanych z jakością zbioru danych. Na tym etapie dokonano czyszczenia
danych oraz imputacji brakujących wartości, wykorzystując metody oparte na korelacjach oraz charakterze braków danych.
Następnie oczyszczonym danym nadano odpowiednie kategorie, co umożliwiło ich dalszą analizę wizualną.

Kolejnym etapem badania była wizualizacja danych, która pozwoliła na przedstawienie zależności między poszczególnymi
zmiennymi w sposób czytelny dla odbiorcy. Wykonanie analizy opisowej umożliwiło wykrycie potencjalnych zależności i
wzorców występujących w zbiorze danych, co stanowiło podstawę do dalszych analiz.

Wyniki wnioskowania statystycznego wskazały, że na decyzję o odejściu pracowników z przedsiębiorstwa istotny wpływ mają
zmienne związane z częstotliwością podróży służbowych (**business_travel**), satysfakcji z pracy (**job_satisfaction**)
oraz miesięcznym dochodem (**monthly_income**). Oznacza to, że miejsce odbywania podróży służbowych, dochody oraz
satysfakcja z pracy stanowią kluczowe determinanty decyzji o odejściu pracowników. Podsumowując, przeprowadzone analizy
pozwoliły na wyodrębnienie najważniejszych czynników wpływających na odejście pracowników z przedsiębiorstwa, co stanowi
cenny wkład w dalsze badania nad dynamiką zatrudnienia.
